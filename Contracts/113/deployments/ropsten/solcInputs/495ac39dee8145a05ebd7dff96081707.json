{
  "language": "Solidity",
  "sources": {
    "contracts/Cauldron.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Cauldron\r\n\r\n//    (                (   (\r\n//    )\\      )    (   )\\  )\\ )  (\r\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\r\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\r\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\r\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\r\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\r\n\r\n// Copyright (c) 2021 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @0xKeno - for all his invaluable contributions\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\r\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\r\nimport \"./MagicInternetMoney.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\n\r\n// solhint-disable avoid-low-level-calls\r\n// solhint-disable no-inline-assembly\r\n\r\n/// @title Cauldron\r\n/// @dev This contract allows contract calls to any contract (except BentoBox)\r\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\r\ncontract Cauldron is BoringOwnable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n    using RebaseLibrary for Rebase;\r\n    using BoringERC20 for IERC20;\r\n\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(uint128 accruedAmount);\r\n    event LogAddCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\r\n\r\n    // Immutables (for MasterContract and all clones)\r\n    IBentoBoxV1 public immutable bentoBox;\r\n    Cauldron public immutable masterContract;\r\n    IERC20 public immutable magicInternetMoney;\r\n\r\n    // MasterContract variables\r\n    address public feeTo;\r\n\r\n    // Per clone variables\r\n    // Clone init settings\r\n    IERC20 public collateral;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralShare; // Total collateral supplied\r\n    Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralShare;\r\n    mapping(address => uint256) public userBorrowPart;\r\n\r\n    /// @notice Exchange and interest rate tracking.\r\n    /// This is 'cached' here because calls to Oracles can be very expensive.\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 lastAccrued;\r\n        uint128 feesEarned;\r\n    }\r\n\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // Settings\r\n    uint256 private constant INTEREST_PER_SECOND = 317097920;\r\n\r\n    uint256 private constant COLLATERIZATION_RATE = 75000; // 75%\r\n    uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)\r\n\r\n    uint256 private constant EXCHANGE_RATE_PRECISION = 1e18;\r\n\r\n    uint256 private constant LIQUIDATION_MULTIPLIER = 112000; // add 12%\r\n    uint256 private constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\r\n\r\n    uint256 private constant BORROW_OPENING_FEE = 50; // 0.05%\r\n    uint256 private constant BORROW_OPENING_FEE_PRECISION = 1e5;\r\n\r\n    /// @notice The constructor is only used for the initial master contract. Subsequent clones are initialised via `init`.\r\n    constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) public {\r\n        bentoBox = bentoBox_;\r\n        magicInternetMoney = magicInternetMoney_;\r\n        masterContract = this;\r\n    }\r\n\r\n    /// @notice Serves as the constructor for clones, as clones can't have a regular constructor\r\n    /// @dev `data` is abi encoded in the format: (IERC20 collateral, IERC20 asset, IOracle oracle, bytes oracleData)\r\n    function init(bytes calldata data) public payable override {\r\n        require(address(collateral) == address(0), \"Cauldron: already initialized\");\r\n        (collateral, oracle, oracleData) = abi.decode(data, (IERC20, IOracle, bytes));\r\n        require(address(collateral) != address(0), \"Cauldron: bad pair\");\r\n    }\r\n\r\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\r\n    function accrue() public {\r\n        AccrueInfo memory _accrueInfo = accrueInfo;\r\n        // Number of seconds since accrue was called\r\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\r\n        if (elapsedTime == 0) {\r\n            return;\r\n        }\r\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        if (_totalBorrow.base == 0) {\r\n            accrueInfo = _accrueInfo;\r\n            return;\r\n        }\r\n\r\n        // Accrue interest\r\n        uint128 extraAmount = (uint256(_totalBorrow.elastic).mul(INTEREST_PER_SECOND).mul(elapsedTime) / 1e18).to128();\r\n        _totalBorrow.elastic = _totalBorrow.elastic.add(extraAmount);\r\n\r\n        _accrueInfo.feesEarned = _accrueInfo.feesEarned.add(extraAmount);\r\n        totalBorrow = _totalBorrow;\r\n        accrueInfo = _accrueInfo;\r\n\r\n        emit LogAccrue(extraAmount);\r\n    }\r\n\r\n    /// @notice Concrete implementation of `isSolvent`. Includes a third parameter to allow caching `exchangeRate`.\r\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\r\n    function _isSolvent(address user, uint256 _exchangeRate) internal view returns (bool) {\r\n        // accrue must have already been called!\r\n        uint256 borrowPart = userBorrowPart[user];\r\n        if (borrowPart == 0) return true;\r\n        uint256 collateralShare = userCollateralShare[user];\r\n        if (collateralShare == 0) return false;\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n\r\n        return\r\n            bentoBox.toAmount(\r\n                collateral,\r\n                collateralShare.mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION).mul(COLLATERIZATION_RATE),\r\n                false\r\n            ) >=\r\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\r\n            borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;\r\n    }\r\n\r\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\r\n    modifier solvent() {\r\n        _;\r\n        require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\r\n    }\r\n\r\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\r\n    /// This function is supposed to be invoked if needed because Oracle queries can be expensive.\r\n    /// @return updated True if `exchangeRate` was updated.\r\n    /// @return rate The new exchange rate.\r\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\r\n        (updated, rate) = oracle.get(oracleData);\r\n\r\n        if (updated) {\r\n            exchangeRate = rate;\r\n            emit LogExchangeRate(rate);\r\n        } else {\r\n            // Return the old rate if fetching wasn't successful\r\n            rate = exchangeRate;\r\n        }\r\n    }\r\n\r\n    /// @dev Helper function to move tokens.\r\n    /// @param token The ERC-20 token.\r\n    /// @param share The amount in shares to add.\r\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\r\n    /// Only used for accounting checks.\r\n    /// @param skim If True, only does a balance check on this contract.\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    function _addTokens(\r\n        IERC20 token,\r\n        uint256 share,\r\n        uint256 total,\r\n        bool skim\r\n    ) internal {\r\n        if (skim) {\r\n            require(share <= bentoBox.balanceOf(token, address(this)).sub(total), \"Cauldron: Skim too much\");\r\n        } else {\r\n            bentoBox.transfer(token, msg.sender, address(this), share);\r\n        }\r\n    }\r\n\r\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\r\n    /// @param to The receiver of the tokens.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.x\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    /// @param share The amount of shares to add for `to`.\r\n    function addCollateral(\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) public {\r\n        userCollateralShare[to] = userCollateralShare[to].add(share);\r\n        uint256 oldTotalCollateralShare = totalCollateralShare;\r\n        totalCollateralShare = oldTotalCollateralShare.add(share);\r\n        _addTokens(collateral, share, oldTotalCollateralShare, skim);\r\n        emit LogAddCollateral(skim ? address(bentoBox) : msg.sender, to, share);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `removeCollateral`.\r\n    function _removeCollateral(address to, uint256 share) internal {\r\n        userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);\r\n        totalCollateralShare = totalCollateralShare.sub(share);\r\n        emit LogRemoveCollateral(msg.sender, to, share);\r\n        bentoBox.transfer(collateral, address(this), to, share);\r\n    }\r\n\r\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\r\n    /// @param to The receiver of the shares.\r\n    /// @param share Amount of shares to remove.\r\n    function removeCollateral(address to, uint256 share) public solvent {\r\n        // accrue must be called because we check solvency\r\n        accrue();\r\n        _removeCollateral(to, share);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `borrow`.\r\n    function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\r\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\r\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));\r\n        userBorrowPart[msg.sender] = userBorrowPart[msg.sender].add(part);\r\n\r\n        // As long as there are tokens on this contract you can 'mint'... this enables limiting borrows\r\n        share = bentoBox.toShare(magicInternetMoney, amount, false);\r\n        bentoBox.transfer(magicInternetMoney, address(this), to, share);\r\n\r\n        emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);\r\n    }\r\n\r\n    /// @notice Sender borrows `amount` and transfers it to `to`.\r\n    /// @return part Total part of the debt held by borrowers.\r\n    /// @return share Total amount in shares borrowed.\r\n    function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {\r\n        accrue();\r\n        (part, share) = _borrow(to, amount);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `repay`.\r\n    function _repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) internal returns (uint256 amount) {\r\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\r\n        userBorrowPart[to] = userBorrowPart[to].sub(part);\r\n\r\n        uint256 share = bentoBox.toShare(magicInternetMoney, amount, true);\r\n        bentoBox.transfer(magicInternetMoney, skim ? address(bentoBox) : msg.sender, address(this), share);\r\n        emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);\r\n    }\r\n\r\n    /// @notice Repays a loan.\r\n    /// @param to Address of the user this payment should go.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    /// @param part The amount to repay. See `userBorrowPart`.\r\n    /// @return amount The total amount repayed.\r\n    function repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) public returns (uint256 amount) {\r\n        accrue();\r\n        amount = _repay(to, skim, part);\r\n    }\r\n\r\n    // Functions that need accrue to be called\r\n    uint8 internal constant ACTION_REPAY = 2;\r\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\r\n    uint8 internal constant ACTION_BORROW = 5;\r\n    uint8 internal constant ACTION_GET_REPAY_SHARE = 6;\r\n    uint8 internal constant ACTION_GET_REPAY_PART = 7;\r\n    uint8 internal constant ACTION_ACCRUE = 8;\r\n\r\n    // Functions that don't need accrue to be called\r\n    uint8 internal constant ACTION_ADD_COLLATERAL = 10;\r\n    uint8 internal constant ACTION_UPDATE_EXCHANGE_RATE = 11;\r\n\r\n    // Function on BentoBox\r\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\r\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\r\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\r\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\r\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\r\n\r\n    // Any external call (except to BentoBox)\r\n    uint8 internal constant ACTION_CALL = 30;\r\n\r\n    int256 internal constant USE_VALUE1 = -1;\r\n    int256 internal constant USE_VALUE2 = -2;\r\n\r\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\r\n    function _num(\r\n        int256 inNum,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal pure returns (uint256 outNum) {\r\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\r\n    }\r\n\r\n    /// @dev Helper function for depositing into `bentoBox`.\r\n    function _bentoDeposit(\r\n        bytes memory data,\r\n        uint256 value,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (uint256, uint256) {\r\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\r\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\r\n        share = int256(_num(share, value1, value2));\r\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\r\n    }\r\n\r\n    /// @dev Helper function to withdraw from the `bentoBox`.\r\n    function _bentoWithdraw(\r\n        bytes memory data,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (uint256, uint256) {\r\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\r\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\r\n    }\r\n\r\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\r\n    /// Calls to `bentoBox` are not allowed for obvious security reasons.\r\n    /// This also means that calls made from this contract shall *not* be trusted.\r\n    function _call(\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (bytes memory, uint8) {\r\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) =\r\n            abi.decode(data, (address, bytes, bool, bool, uint8));\r\n\r\n        if (useValue1 && !useValue2) {\r\n            callData = abi.encodePacked(callData, value1);\r\n        } else if (!useValue1 && useValue2) {\r\n            callData = abi.encodePacked(callData, value2);\r\n        } else if (useValue1 && useValue2) {\r\n            callData = abi.encodePacked(callData, value1, value2);\r\n        }\r\n\r\n        require(callee != address(bentoBox) && callee != address(this), \"Cauldron: can't call\");\r\n\r\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\r\n        require(success, \"Cauldron: call failed\");\r\n        return (returnData, returnValues);\r\n    }\r\n\r\n    struct CookStatus {\r\n        bool needsSolvencyCheck;\r\n        bool hasAccrued;\r\n    }\r\n\r\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\r\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\r\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\r\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\r\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\r\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\r\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\r\n    function cook(\r\n        uint8[] calldata actions,\r\n        uint256[] calldata values,\r\n        bytes[] calldata datas\r\n    ) external payable returns (uint256 value1, uint256 value2) {\r\n        CookStatus memory status;\r\n        for (uint256 i = 0; i < actions.length; i++) {\r\n            uint8 action = actions[i];\r\n            if (!status.hasAccrued && action < 10) {\r\n                accrue();\r\n                status.hasAccrued = true;\r\n            }\r\n            if (action == ACTION_ADD_COLLATERAL) {\r\n                (int256 share, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\r\n                addCollateral(to, skim, _num(share, value1, value2));\r\n            } else if (action == ACTION_REPAY) {\r\n                (int256 part, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\r\n                _repay(to, skim, _num(part, value1, value2));\r\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\r\n                (int256 share, address to) = abi.decode(datas[i], (int256, address));\r\n                _removeCollateral(to, _num(share, value1, value2));\r\n                status.needsSolvencyCheck = true;\r\n            } else if (action == ACTION_BORROW) {\r\n                (int256 amount, address to) = abi.decode(datas[i], (int256, address));\r\n                (value1, value2) = _borrow(to, _num(amount, value1, value2));\r\n                status.needsSolvencyCheck = true;\r\n            } else if (action == ACTION_UPDATE_EXCHANGE_RATE) {\r\n                (bool must_update, uint256 minRate, uint256 maxRate) = abi.decode(datas[i], (bool, uint256, uint256));\r\n                (bool updated, uint256 rate) = updateExchangeRate();\r\n                require((!must_update || updated) && rate > minRate && (maxRate == 0 || rate > maxRate), \"Cauldron: rate not ok\");\r\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\r\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) =\r\n                    abi.decode(datas[i], (address, address, bool, uint8, bytes32, bytes32));\r\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\r\n            } else if (action == ACTION_BENTO_DEPOSIT) {\r\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\r\n            } else if (action == ACTION_BENTO_WITHDRAW) {\r\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\r\n            } else if (action == ACTION_BENTO_TRANSFER) {\r\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\r\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\r\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\r\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\r\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\r\n            } else if (action == ACTION_CALL) {\r\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\r\n\r\n                if (returnValues == 1) {\r\n                    (value1) = abi.decode(returnData, (uint256));\r\n                } else if (returnValues == 2) {\r\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\r\n                }\r\n            } else if (action == ACTION_GET_REPAY_SHARE) {\r\n                int256 part = abi.decode(datas[i], (int256));\r\n                value1 = bentoBox.toShare(magicInternetMoney, totalBorrow.toElastic(_num(part, value1, value2), true), true);\r\n            } else if (action == ACTION_GET_REPAY_PART) {\r\n                int256 amount = abi.decode(datas[i], (int256));\r\n                value1 = totalBorrow.toBase(_num(amount, value1, value2), false);\r\n            }\r\n        }\r\n\r\n        if (status.needsSolvencyCheck) {\r\n            require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\r\n        }\r\n    }\r\n\r\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\r\n    /// @param users An array of user addresses.\r\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\r\n    /// @param to Address of the receiver in open liquidations if `swapper` is zero.\r\n    function liquidate(\r\n        address[] calldata users,\r\n        uint256[] calldata maxBorrowParts,\r\n        address to,\r\n        ISwapper swapper\r\n    ) public {\r\n        // Oracle can fail but we still need to allow liquidations\r\n        (, uint256 _exchangeRate) = updateExchangeRate();\r\n        accrue();\r\n\r\n        uint256 allCollateralShare;\r\n        uint256 allBorrowAmount;\r\n        uint256 allBorrowPart;\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!_isSolvent(user, _exchangeRate)) {\r\n                uint256 borrowPart;\r\n                {\r\n                    uint256 availableBorrowPart = userBorrowPart[user];\r\n                    borrowPart = maxBorrowParts[i] > availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];\r\n                    userBorrowPart[user] = availableBorrowPart.sub(borrowPart);\r\n                }\r\n                uint256 borrowAmount = _totalBorrow.toElastic(borrowPart, false);\r\n                uint256 collateralShare =\r\n                    bentoBoxTotals.toBase(\r\n                        borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /\r\n                            (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),\r\n                        false\r\n                    );\r\n\r\n                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);\r\n                emit LogRemoveCollateral(user, to, collateralShare);\r\n                emit LogRepay(msg.sender, user, borrowAmount, borrowPart);\r\n\r\n                // Keep totals\r\n                allCollateralShare = allCollateralShare.add(collateralShare);\r\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\r\n                allBorrowPart = allBorrowPart.add(borrowPart);\r\n            }\r\n        }\r\n        require(allBorrowAmount != 0, \"Cauldron: all are solvent\");\r\n        _totalBorrow.elastic = _totalBorrow.elastic.sub(allBorrowAmount.to128());\r\n        _totalBorrow.base = _totalBorrow.base.sub(allBorrowPart.to128());\r\n        totalBorrow = _totalBorrow;\r\n        totalCollateralShare = totalCollateralShare.sub(allCollateralShare);\r\n\r\n        uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);\r\n\r\n        // Swap using a swapper freely chosen by the caller\r\n        // Open (flash) liquidation: get proceeds first and provide the borrow after\r\n        bentoBox.transfer(collateral, address(this), to, allCollateralShare);\r\n        if (swapper != ISwapper(0)) {\r\n            swapper.swap(collateral, magicInternetMoney, msg.sender, allBorrowShare, allCollateralShare);\r\n        }\r\n\r\n        bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);\r\n    }\r\n\r\n    /// @notice Withdraws the fees accumulated.\r\n    function withdrawFees() public {\r\n        accrue();\r\n        address _feeTo = masterContract.feeTo();\r\n        uint256 _feesEarned = accrueInfo.feesEarned;\r\n        uint256 share = bentoBox.toShare(magicInternetMoney, _feesEarned, false);\r\n        bentoBox.transfer(magicInternetMoney, address(this), _feeTo, share);\r\n        accrueInfo.feesEarned = 0;\r\n\r\n        emit LogWithdrawFees(_feeTo, _feesEarned);\r\n    }\r\n\r\n    /// @notice Sets the beneficiary of interest accrued.\r\n    /// MasterContract Only Admin function.\r\n    /// @param newFeeTo The address of the receiver.\r\n    function setFeeTo(address newFeeTo) public onlyOwner {\r\n        feeTo = newFeeTo;\r\n        emit LogFeeTo(newFeeTo);\r\n    }\r\n\r\n    /// @notice reduces the supply of MIM\r\n    /// @param amount amount to reduce supply by\r\n    function reduceSupply(uint256 amount) public {\r\n        require(msg.sender == masterContract.owner(), \"Caller is not the owner\");\r\n        bentoBox.withdraw(magicInternetMoney, address(this), address(this), amount, 0);\r\n        MagicInternetMoney(address(magicInternetMoney)).burn(amount);\r\n    }\r\n}\r\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\n        c = uint32(a);\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() public {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./interfaces/IERC20.sol\";\nimport \"./Domain.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable not-rely-on-time\n\n// Data part taken out for building of contracts that receive delegate calls\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\nabstract contract ERC20 is IERC20, Domain {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public override balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param amount of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0 || msg.sender == to) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param amount The token amount to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount;\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n        require(block.timestamp < deadline, \"ERC20: Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"ERC20: Invalid Signature\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n}\n\ncontract ERC20WithSupply is IERC20, ERC20 {\n    uint256 public override totalSupply;\n\n    function _mint(address user, uint256 amount) internal {\n        uint256 newTotalSupply = totalSupply + amount;\n        require(newTotalSupply >= totalSupply, \"Mint overflow\");\n        totalSupply = newTotalSupply;\n        balanceOf[user] += amount;\n        emit Transfer(address(0), user, amount);\n    }\n\n    function _burn(address user, uint256 amount) internal {\n        require(balanceOf[user] >= amount, \"Burn too much\");\n        totalSupply -= amount;\n        balanceOf[user] -= amount;\n        emit Transfer(user, address(0), amount);\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IMasterContract {\n    /// @notice Init function that gets called from `BoringFactory.deploy`.\n    /// Also kown as the constructor for cloned contracts.\n    /// Any ETH send to `BoringFactory.deploy` ends up here.\n    /// @param data Can be abi encoded arguments or anything else.\n    function init(bytes calldata data) external payable;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"./BoringMath.sol\";\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = elastic.mul(total.base) / total.elastic;\n            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\n                base = base.add(1);\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = base.mul(total.elastic) / total.base;\n            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\n                elastic = elastic.add(1);\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.add(elastic.to128());\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.sub(elastic.to128());\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IERC20.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while (i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        require(success && data.length >= 32, \"BoringERC20: BalanceOf failed\");\n        amount = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n"
    },
    "@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\nimport '@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol';\nimport './IBatchFlashBorrower.sol';\nimport './IFlashBorrower.sol';\nimport './IStrategy.sol';\n\ninterface IBentoBoxV1 {\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event LogFlashLoan(address indexed borrower, address indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\n    event LogRegisterProtocol(address indexed protocol);\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\n    event LogStrategyDivest(address indexed token, uint256 amount);\n    event LogStrategyInvest(address indexed token, uint256 amount);\n    event LogStrategyLoss(address indexed token, uint256 amount);\n    event LogStrategyProfit(address indexed token, uint256 amount);\n    event LogStrategyQueued(address indexed token, address indexed strategy);\n    event LogStrategySet(address indexed token, address indexed strategy);\n    event LogStrategyTargetPercentage(address indexed token, uint256 targetPercentage);\n    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 share);\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\n    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function balanceOf(IERC20, address) external view returns (uint256);\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\n    function batchFlashLoan(IBatchFlashBorrower borrower, address[] calldata receivers, IERC20[] calldata tokens, uint256[] calldata amounts, bytes calldata data) external;\n    function claimOwnership() external;\n    function deploy(address masterContract, bytes calldata data, bool useCreate2) external payable;\n    function deposit(IERC20 token_, address from, address to, uint256 amount, uint256 share) external payable returns (uint256 amountOut, uint256 shareOut);\n    function flashLoan(IFlashBorrower borrower, address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n    function harvest(IERC20 token, bool balance, uint256 maxChangeAmount) external;\n    function masterContractApproved(address, address) external view returns (bool);\n    function masterContractOf(address) external view returns (address);\n    function nonces(address) external view returns (uint256);\n    function owner() external view returns (address);\n    function pendingOwner() external view returns (address);\n    function pendingStrategy(IERC20) external view returns (IStrategy);\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function registerProtocol() external;\n    function setMasterContractApproval(address user, address masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) external;\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\n    function strategy(IERC20) external view returns (IStrategy);\n    function strategyData(IERC20) external view returns (uint64 strategyStartDate, uint64 targetPercentage, uint128 balance);\n    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\n    function toShare(IERC20 token, uint256 amount, bool roundUp) external view returns (uint256 share);\n    function totals(IERC20) external view returns (Rebase memory totals_);\n    function transfer(IERC20 token, address from, address to, uint256 share) external;\n    function transferMultiple(IERC20 token, address from, address[] calldata tos, uint256[] calldata shares) external;\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n    function whitelistMasterContract(address masterContract, bool approved) external;\n    function whitelistedMasterContracts(address) external view returns (bool);\n    function withdraw(IERC20 token_, address from, address to, uint256 amount, uint256 share) external returns (uint256 amountOut, uint256 shareOut);\n}"
    },
    "contracts/MagicInternetMoney.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n// Magic Internet Money\r\n\r\n//       \r\n//   \r\n// \r\n// \r\n//     \r\n//           \r\n\r\n// BoringCrypto, 0xMerlin\r\n\r\npragma solidity 0.6.12;\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\r\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\r\n\r\n/// @title Cauldron\r\n/// @dev This contract allows contract calls to any contract (except BentoBox)\r\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\r\ncontract MagicInternetMoney is ERC20, BoringOwnable {\r\n    using BoringMath for uint256;\r\n    // ERC20 'variables'\r\n    string public constant symbol = \"MIM\";\r\n    string public constant name = \"Magic Internet Money\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public override totalSupply;\r\n\r\n    struct Minting {\r\n        uint128 time;\r\n        uint128 amount;\r\n    }\r\n\r\n    Minting public lastMint;\r\n    uint256 private constant MINTING_PERIOD = 24 hours;\r\n    uint256 private constant MINTING_INCREASE = 15000;\r\n    uint256 private constant MINTING_PRECISION = 1e5;\r\n\r\n    function mint(address to, uint256 amount) public onlyOwner {\r\n        require(to != address(0), \"MIM: no mint to zero address\");\r\n\r\n        // Limits the amount minted per period to a convergence function, with the period duration restarting on every mint\r\n        uint256 totalMintedAmount = uint256(lastMint.time < block.timestamp - MINTING_PERIOD ? 0 : lastMint.amount).add(amount);\r\n        require(totalSupply == 0 || totalSupply.mul(MINTING_INCREASE) / MINTING_PRECISION >= totalMintedAmount);\r\n\r\n        lastMint.time = block.timestamp.to128();\r\n        lastMint.amount = totalMintedAmount.to128();\r\n\r\n        totalSupply = totalSupply + amount;\r\n        balanceOf[to] += amount;\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function mintToBentoBox(address clone, uint256 amount, IBentoBoxV1 bentoBox) public onlyOwner {\r\n        mint(address(bentoBox), amount);\r\n        bentoBox.deposit(IERC20(address(this)), address(bentoBox), clone, amount, 0);\r\n    }\r\n\r\n    function burn(uint256 amount) public {\r\n        require(amount <= balanceOf[msg.sender], \"MIM: not enough\");\r\n\r\n        balanceOf[msg.sender] -= amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\n\ninterface ISwapper {\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for at least 'amountToMin' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\n    /// this should be less than or equal to amountFromMax.\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) external returns (uint256 shareUsed, uint256 shareReturned);\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/Domain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on code and smartness by Ross Campbell and Keno\n// Uses immutable to store the domain separator to reduce gas usage\n// If the chain id changes due to a fork, the forked chain will calculate on the fly.\npragma solidity 0.6.12;\n\n// solhint-disable no-inline-assembly\n\ncontract Domain {\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n\n    // solhint-disable var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    /// @dev Calculate the DOMAIN_SEPARATOR\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));\n    }\n\n    constructor() public {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR\n    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n    // solhint-disable-next-line func-name-mixedcase\n    function _domainSeparator() internal view returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n    }\n}\n"
    },
    "@sushiswap/bentobox-sdk/contracts/IBatchFlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\n\ninterface IBatchFlashBorrower {\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}"
    },
    "@sushiswap/bentobox-sdk/contracts/IFlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport '@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol';\n\ninterface IFlashBorrower {\n    function onFlashLoan(\n        address sender,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external;\n}"
    },
    "@sushiswap/bentobox-sdk/contracts/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IStrategy {\n    // Send the assets to the Strategy and call skim to invest them\n    function skim(uint256 amount) external;\n\n    // Harvest any profits made converted to the asset and pass them to the caller\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    // Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n    // The actualAmount should be very close to the amount. The difference should NOT be used to report a loss. That's what harvest is for.\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    // Withdraw all assets in the safest way possible. This shouldn't fail.\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}"
    },
    "contracts/swappers/SushiSwapSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ncontract SushiSwapSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    IUniswapV2Factory public immutable factory;\n    bytes32 public immutable pairCodeHash;\n\n    constructor(\n        IBentoBoxV1 bentoBox_,\n        IUniswapV2Factory factory_,\n        bytes32 pairCodeHash_\n    ) public {\n        bentoBox = bentoBox_;\n        factory = factory_;\n        pairCodeHash = pairCodeHash_;\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (IERC20 token0, IERC20 token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\n        IUniswapV2Pair pair =\n            IUniswapV2Pair(\n                uint256(\n                    keccak256(abi.encodePacked(hex\"ff\", factory, keccak256(abi.encodePacked(address(token0), address(token1))), pairCodeHash))\n                )\n            );\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(pair), 0, shareFrom);\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        uint256 amountTo;\n        if (toToken > fromToken) {\n            amountTo = getAmountOut(amountFrom, reserve0, reserve1);\n            pair.swap(0, amountTo, address(bentoBox), new bytes(0));\n        } else {\n            amountTo = getAmountOut(amountFrom, reserve1, reserve0);\n            pair.swap(amountTo, 0, address(bentoBox), new bytes(0));\n        }\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        IUniswapV2Pair pair;\n        {\n            (IERC20 token0, IERC20 token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\n            pair = IUniswapV2Pair(\n                uint256(\n                    keccak256(abi.encodePacked(hex\"ff\", factory, keccak256(abi.encodePacked(address(token0), address(token1))), pairCodeHash))\n                )\n            );\n        }\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        uint256 amountToExact = bentoBox.toAmount(toToken, shareToExact, true);\n\n        uint256 amountFrom;\n        if (toToken > fromToken) {\n            amountFrom = getAmountIn(amountToExact, reserve0, reserve1);\n            (, shareUsed) = bentoBox.withdraw(fromToken, address(this), address(pair), amountFrom, 0);\n            pair.swap(0, amountToExact, address(bentoBox), \"\");\n        } else {\n            amountFrom = getAmountIn(amountToExact, reserve1, reserve0);\n            (, shareUsed) = bentoBox.withdraw(fromToken, address(this), address(pair), amountFrom, 0);\n            pair.swap(amountToExact, 0, address(bentoBox), \"\");\n        }\n        bentoBox.deposit(toToken, address(bentoBox), recipient, 0, shareToExact);\n        shareReturned = shareFromSupplied.sub(shareUsed);\n        if (shareReturned > 0) {\n            bentoBox.transfer(fromToken, address(this), refundTo, shareReturned);\n        }\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setMigrator(address) external;\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/swappers/SushiSwapMultiSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/libraries/TransferHelper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ncontract SushiSwapMultiSwapper {\n    using BoringERC20 for IERC20;\n    using BoringMath for uint256;\n\n    address private immutable factory;\n\n    IBentoBoxV1 private immutable bentoBox;\n\n    bytes32 private immutable pairCodeHash;\n\n    constructor(\n        address _factory,\n        IBentoBoxV1 _bentoBox,\n        bytes32 _pairCodeHash\n    ) public {\n        factory = _factory;\n        bentoBox = _bentoBox;\n        pairCodeHash = _pairCodeHash;\n    }\n\n    function getOutputAmount(\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountMinOut,\n        address[] calldata path,\n        uint256 shareIn\n    ) external view returns (uint256 amountOut) {\n        uint256 amountIn = bentoBox.toAmount(tokenIn, shareIn, false);\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\n        amountOut = amounts[amounts.length - 1];\n    }\n\n    function swap(\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountMinOut,\n        address[] calldata path,\n        uint256 shareIn\n    ) external returns (uint256 amountOut, uint256 shareOut) {\n        (uint256 amountIn, ) = bentoBox.withdraw(tokenIn, address(this), address(this), 0, shareIn);\n        amountOut = _swapExactTokensForTokens(amountIn, amountMinOut, path, address(bentoBox));\n        (, shareOut) = bentoBox.deposit(tokenOut, address(bentoBox), msg.sender, amountOut, 0);\n    }\n\n    // Swaps an exact amount of tokens for another token through the path passed as an argument\n    // Returns the amount of the final token\n    function _swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to\n    ) internal returns (uint256 amountOut) {\n        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\n        amountOut = amounts[amounts.length - 1];\n        require(amountOut >= amountOutMin, \"insufficient-amount-out\");\n        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amountIn);\n        _swap(amounts, path, to);\n    }\n\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(\n        uint256[] memory amounts,\n        address[] memory path,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2], pairCodeHash) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output, pairCodeHash)).swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\n\nimport \"@sushiswap/core/contracts/uniswapv2/libraries/SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMathUniswap for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bytes32 pairCodeHash\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        pairCodeHash // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i], pairCodeHash);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.6.12;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMathUniswap {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/swappers/SpellSwapper.sol": {
      "content": "// License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/libraries/TransferHelper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract SpellSwapper is BoringOwnable {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);    \n    IERC20 public constant SPELL = IERC20(0x090185f2135308BaD17527004364eBcC2D37e5F6);\n    address public constant sSPELL = 0x26FA3fFFB6EfE8c1E69103aCb4044C26B9A106a9;\n    IUniswapV2Pair constant SPELL_WETH = IUniswapV2Pair(0xb5De0C3753b6E1B4dBA616Db82767F17513E6d4E);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    address public constant treasury = 0x5A7C5505f3CFB9a0D9A8493EC41bf27EE48c406D;\n    mapping (address => bool) public verified;\n\n    constructor(\n    ) public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        verified[msg.sender] = true;\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    modifier onlyVerified {\n        require(verified[msg.sender], \"Only verified operators\");\n        _;\n    }\n\n    function setVerified(address operator, bool status) public onlyOwner {\n        verified[operator] = status;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        uint256 amountToMin\n    ) public onlyVerified{\n\n        uint256 amountFirst;\n        uint256 amountIntermediate;\n\n        {\n\n        uint256 shareFrom = bentoBox.balanceOf(MIM, address(this));\n\n        uint256 treasuryShare = shareFrom / 4;\n\n        bentoBox.withdraw(MIM, address(this), treasury, 0, treasuryShare);\n\n        (uint256 amountMIMFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom.sub(treasuryShare));\n\n        amountFirst = MIM3POOL.exchange_underlying(0, 3, amountMIMFrom, 0, address(pair));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        amountIntermediate = getAmountOut(amountFirst, reserve1, reserve0);\n\n        }\n\n        uint256 amountThird;\n\n        {\n        \n        pair.swap(amountIntermediate, 0, address(SPELL_WETH), new bytes(0));\n\n        (uint256 reserve0, uint256 reserve1, ) = SPELL_WETH.getReserves();\n        \n        amountThird = getAmountOut(amountIntermediate, reserve1, reserve0);\n        \n        require(amountThird >= amountToMin, \"Minimum must be reached\");\n\n        }\n\n        SPELL_WETH.swap(amountThird, 0, sSPELL, new bytes(0));\n    }\n\n}"
    },
    "contracts/Spell.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Spell\n\n// Special thanks to:\n// @BoringCrypto for his great libraries\n\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\n\n/// @title Spell\n/// @author 0xMerlin\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract Spell is ERC20, BoringOwnable {\n    using BoringMath for uint256;\n    // ERC20 'variables'\n    string public constant symbol = \"SPELL\";\n    string public constant name = \"Spell Token\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 public constant MAX_SUPPLY = 420 * 1e27;\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        require(to != address(0), \"SPELL: no mint to zero address\");\n        require(MAX_SUPPLY >= totalSupply.add(amount), \"SPELL: Don't go over MAX\");\n\n        totalSupply = totalSupply + amount;\n        balanceOf[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n}\n"
    },
    "contracts/sSpell.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\";\n\n\n// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)\n// modified by BoringCrypto for DictatorDAO\n\ncontract sSpell is IERC20, Domain {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n\n    string public constant symbol = \"sSPELL\";\n    string public constant name = \"Staked Spell Tokens\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 private constant LOCK_TIME = 24 hours;\n\n    IERC20 public immutable token;\n\n    constructor(IERC20 _token) public {\n        token = _token;\n    }\n\n    struct User {\n        uint128 balance;\n        uint128 lockedUntil;\n    }\n\n    /// @notice owner > balance mapping.\n    mapping(address => User) public users;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function balanceOf(address user) public view override returns (uint256 balance) {\n        return users[user].balance;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        User memory fromUser = users[from];\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n        if (shares != 0) {\n            require(fromUser.balance >= shares, \"Low balance\");\n            if (from != to) {\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n                User memory toUser = users[to];\n                users[from].balance = fromUser.balance - shares.to128(); // Underflow is checked\n                users[to].balance = toUser.balance + shares.to128(); // Can't overflow because totalSupply would be greater than 2^128-1;\n            }\n        }\n        emit Transfer(from, to, shares);\n    }\n\n    function _useAllowance(address from, uint256 shares) internal {\n        if (msg.sender == from) {\n            return;\n        }\n        uint256 spenderAllowance = allowance[from][msg.sender];\n        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n        if (spenderAllowance != type(uint256).max) {\n            require(spenderAllowance >= shares, \"Low allowance\");\n            allowance[from][msg.sender] = spenderAllowance - shares; // Underflow is checked\n        }\n    }\n\n    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.\n    /// @param to The address to move the tokens.\n    /// @param shares of the tokens to move.\n    /// @return (bool) Returns True if succeeded.\n    function transfer(address to, uint256 shares) public returns (bool) {\n        _transfer(msg.sender, to, shares);\n        return true;\n    }\n\n    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.\n    /// @param from Address to draw tokens from.\n    /// @param to The address to move the tokens.\n    /// @param shares The token shares to move.\n    /// @return (bool) Returns True if succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _transfer(from, to, shares);\n        return true;\n    }\n\n    /// @notice Approves `amount` from sender to be spend by `spender`.\n    /// @param spender Address of the party that can draw from msg.sender's account.\n    /// @param amount The maximum collective amount that `spender` can draw.\n    /// @return (bool) Returns True if approved.\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n    /// @param owner_ Address of the owner.\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n    /// @param value The maximum collective amount that `spender` can draw.\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"Zero owner\");\n        require(block.timestamp < deadline, \"Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"Invalid Sig\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n\n    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18\n    /// theoretically you can grow the amount/share ratio, but it's not practical and useless\n    function mint(uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"Zero address\");\n        User memory user = users[msg.sender];\n\n        uint256 totalTokens = token.balanceOf(address(this));\n        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / totalTokens;\n        user.balance += shares.to128();\n        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n        users[msg.sender] = user;\n        totalSupply += shares;\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Transfer(address(0), msg.sender, shares);\n        return true;\n    }\n\n    function _burn(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        require(to != address(0), \"Zero address\");\n        User memory user = users[from];\n        require(block.timestamp >= user.lockedUntil, \"Locked\");\n        uint256 amount = (shares * token.balanceOf(address(this))) / totalSupply;\n        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n        totalSupply -= shares;\n\n        token.safeTransfer(to, amount);\n\n        emit Transfer(from, address(0), shares);\n    }\n\n    function burn(address to, uint256 shares) public returns (bool) {\n        _burn(msg.sender, to, shares);\n        return true;\n    }\n\n    function burnFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _burn(from, to, shares);\n        return true;\n    }\n}"
    },
    "@boringcrypto/boring-solidity/contracts/BoringBatchable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\nimport \"./interfaces/IERC20.sol\";\n\ncontract BaseBoringBatchable {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n    // C3: The length of the loop is fully under user control, so can't be exploited\n    // C7: Delegatecall is only used on the same contract, so it's safe\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            if (!success && revertOnFail) {\n                revert(_getRevertMsg(result));\n            }\n        }\n    }\n}\n\ncontract BoringBatchable is BaseBoringBatchable {\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n    /// Lookup `IERC20.permit`.\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/YVYFISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw(uint256 maxShares, address recipient) external returns (uint256);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract YVYFISwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    YearnVault public constant YFI_VAULT = YearnVault(0xE14d13d8B3b85aF791b2AADD661cDBd5E6097Db1);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IUniswapV2Pair constant YFI_WETH = IUniswapV2Pair(0x088ee5007C98a9677165D78dD2109AE4a3D04d0C);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n    \n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        uint256 amountFirst;\n\n        {\n\n        bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        uint256 amountFrom = YFI_VAULT.withdraw(type(uint256).max, address(YFI_WETH));\n\n        (uint256 reserve0, uint256 reserve1, ) = YFI_WETH.getReserves();\n        \n        amountFirst = getAmountOut(amountFrom, reserve0, reserve1);\n\n        }\n        \n        YFI_WETH.swap(0, amountFirst, address(pair), new bytes(0));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        uint256 amountIntermediate = getAmountOut(amountFirst, reserve0, reserve1);\n        pair.swap(0, amountIntermediate, address(this), new bytes(0));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/YVWETHSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw(uint256 maxShares, address recipient) external returns (uint256);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\ncontract YVWETHSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    YearnVault public constant WETH_VAULT = YearnVault(0xa258C4606Ca8206D8aA700cE2143D7db854D168c);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        uint256 amountFrom = WETH_VAULT.withdraw(type(uint256).max, address(pair));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        uint256 amountIntermediate = getAmountOut(amountFrom, reserve0, reserve1);\n        pair.swap(0, amountIntermediate, address(this), new bytes(0));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/YVUSDTSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract YVUSDTSwapper is ISwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    YearnVault public constant TETHER_VAULT = YearnVault(0x7Da96a3891Add058AdA2E826306D812C638D87a7);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        uint256 amountFrom =TETHER_VAULT.withdraw();\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountFrom, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (1,1);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/YVUSDCSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n}\n\ncontract YVUSDCSwapper is ISwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IERC20 public constant TETHER = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    YearnVault public constant USDC_VAULT = YearnVault(0x5f18C75AbDAe578b483E5F43f12a39cF75b973a9);\n    IERC20 public constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        USDC.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        uint256 amountFrom = USDC_VAULT.withdraw();\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(2, 0, amountFrom, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (1,1);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/YVUSDTLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract YVUSDTLevSwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    YearnVault public constant USDT_VAULT = YearnVault(0x7Da96a3891Add058AdA2E826306D812C638D87a7);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(USDT_VAULT), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(this));\n\n        uint256 amountTo = USDT_VAULT.deposit(type(uint256).max, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(IERC20(address(USDT_VAULT)), address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/YVUSDCLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\n\ncontract YVUSDCLeverageSwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    YearnVault public constant USDC_VAULT = YearnVault(0x5f18C75AbDAe578b483E5F43f12a39cF75b973a9);\n    IERC20 public constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        USDC.approve(address(USDC_VAULT), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        uint256 amountIntermediate = MIM3POOL.exchange_underlying(0, 2, amountFrom, 0, address(this));\n\n        uint256 amountTo = USDC_VAULT.deposit(type(uint256).max, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(IERC20(address(USDC_VAULT)), address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/YVIBLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount, bool _use_underlying) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract YVIBLevSwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n     // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool constant public IronBank = CurvePool(0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF);\n    YearnVault constant public YVIB = YearnVault(0x27b7b1ad7288079A66d12350c828D3C00A6F07d7);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant CurveToken = IERC20(0x5282a4eF67D9C33135340fB3289cc1711c13638C);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(IronBank), type(uint256).max);\n        CurveToken.approve(address(YVIB), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        uint256 amountIntermediate = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(this));\n\n        uint256[3] memory amountsAdded = [0,0, amountIntermediate];\n\n        IronBank.add_liquidity(amountsAdded, 0, true);\n\n        uint256 amountTo = YVIB.deposit(type(uint256).max, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(IERC20(address(YVIB)), address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/YVCrvStETHLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount, bool _use_underlying) external returns (uint256);\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external payable returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\ninterface IWETH is IERC20 {\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}\n\ncontract YVCrvStETHLevSwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n     // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool constant public STETH = CurvePool(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);\n    YearnVault constant public YVSTETH = YearnVault(0xdCD90C7f6324cfa40d7169ef80b12031770B4325);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant CurveToken = IERC20(0x06325440D014e39736583c165C2963BA99fAf14E);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n    IWETH public constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(STETH), type(uint256).max);\n        CurveToken.approve(address(YVSTETH), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    receive() external payable {}\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n        uint256 amountThird;\n        {\n            uint256 amountSecond = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(pair));\n    \n            (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n            amountThird = getAmountOut(amountSecond, reserve1, reserve0);\n            pair.swap(amountThird, 0, address(this), new bytes(0));\n        }\n\n        WETH.withdraw(amountThird);\n        \n        uint256[2] memory amountsAdded = [amountThird,0];\n\n        STETH.add_liquidity{value: amountThird}(amountsAdded, 0);\n\n        uint256 amountTo = YVSTETH.deposit(type(uint256).max, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(IERC20(address(YVSTETH)), address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/WethLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\n}\n\ninterface IThreeCrypto is CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract WethLevSwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    // Local variables\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IThreeCrypto constant public threecrypto = IThreeCrypto(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(threecrypto), type(uint256).max);\n        WETH.approve(address(degenBox), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = degenBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        uint256 amountOne = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(this));\n\n        threecrypto.exchange(0, 2, amountOne, 0);\n\n        uint256 amountTo = WETH.balanceOf(address(this));\n\n        (, shareReturned) = degenBox.deposit(WETH, address(this), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}"
    },
    "contracts/swappers/Leverage/WbtcLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\n}\n\ninterface IThreeCrypto is CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract WbtcLevSwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    // Local variables\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IThreeCrypto constant public threecrypto = IThreeCrypto(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(threecrypto), type(uint256).max);\n        WBTC.approve(address(degenBox), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = degenBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        uint256 amountOne = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(this));\n\n        threecrypto.exchange(0, 1, amountOne, 0);\n\n        uint256 amountTo = WBTC.balanceOf(address(this));\n\n        (, shareReturned) = degenBox.deposit(WBTC, address(this), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}"
    },
    "contracts/swappers/Leverage/ThreeCryptoLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ninterface IConvex is IERC20{\n    function withdrawAndUnwrap(uint256 _amount) external;\n    //deposit a curve token\n    function deposit(uint256 _amount, address _to) external;\n}\n\ncontract ThreeCryptoLevSwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n     // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool constant public threecrypto = CurvePool(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    IConvex public constant cvx3Crypto = IConvex(0x5958A8DB7dfE0CC49382209069b00F54e17929C2);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant CurveToken = IERC20(0xc4AD29ba4B3c580e6D59105FFf484999997675Ff);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(threecrypto), type(uint256).max);\n        CurveToken.approve(address(cvx3Crypto), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        uint256 amountIntermediate = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(this));\n\n        uint256[3] memory amountsAdded = [amountIntermediate, 0, 0];\n\n        threecrypto.add_liquidity(amountsAdded, 0);\n\n        uint256 amountTo = CurveToken.balanceOf(address(this));\n\n        cvx3Crypto.deposit(amountTo, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(cvx3Crypto, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}"
    },
    "contracts/swappers/Leverage/RenCrvLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\n}\n\ninterface IThreeCrypto is CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ninterface IConvex is IERC20{\n    function withdrawAndUnwrap(uint256 _amount) external;\n    //deposit a curve token\n    function deposit(uint256 _amount, address _to) external;\n}\n\ncontract RenCrvLevSwapper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool constant public renCrv = CurvePool(0x93054188d876f558f4a66B2EF1d97d16eDf0895B);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IThreeCrypto constant public threecrypto = IThreeCrypto(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    IConvex public constant cvxRen = IConvex(0xB65eDE134521F0EFD4E943c835F450137dC6E83e);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant CurveToken = IERC20(0x49849C98ae39Fff122806C06791Fa73784FB3675);\n    IERC20 public constant WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(threecrypto), type(uint256).max);\n        WBTC.approve(address(renCrv), type(uint256).max);\n        CurveToken.approve(address(cvxRen), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        uint256 amountOne = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(this));\n\n        threecrypto.exchange(0, 1, amountOne, 0);\n\n        uint256 amountIntermediate = WBTC.balanceOf(address(this));\n\n        uint256[2] memory amountsAdded = [0, amountIntermediate];\n\n        renCrv.add_liquidity(amountsAdded, 0);\n\n        uint256 amountTo = CurveToken.balanceOf(address(this));\n\n        cvxRen.deposit(amountTo, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(cvxRen, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}"
    },
    "contracts/PrivatePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Cauldron\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/ISimpleSwapper.sol\";\nimport \"./libraries/FullMath.sol\";\n\n/// @title PrivatePool\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract PrivatePool is BoringOwnable, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogExchangeRate(uint256 rate);\n    event LogAccrue(uint256 accruedAmount, uint256 feeAmount);\n    event LogAddCollateral(address indexed from, address indexed to, uint256 share);\n    event LogAddAsset(address indexed from, uint256 share);\n    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);\n    event LogRemoveAsset(address indexed to, uint256 share);\n    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 openFeeAmount, uint256 part);\n    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);\n    event LogSeizeCollateral(address indexed from, uint256 collateralShare, uint256 debtAmount, uint256 debtPart);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 assetFeeShare, uint256 collateralFeeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    PrivatePool public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC20 public collateral;\n    IERC20 public asset;\n    IOracle public oracle;\n    bytes public oracleData;\n\n    // A note on terminology:\n    // \"Shares\" are BentoBox shares.\n    // \"Parts\" and represent shares held in the debt pool\n\n    // The BentoBox balance is the sum of the below two.\n    // Since that fits in a single uint128, we can often forgo overflow checks.\n    struct AssetBalance {\n        uint128 reservesShare;\n        uint128 feesEarnedShare;\n    }\n    AssetBalance public assetBalance;\n    uint256 public feesOwedAmount; // Positive only if reservesShare = 0\n\n    // The BentoBox balance is the sum of the below two.\n    // Seized collateral goes to the \"userCollateralShare\" account of the\n    // lender.\n    struct CollateralBalance {\n        uint128 userTotalShare;\n        uint128 feesEarnedShare;\n    }\n    CollateralBalance public collateralBalance;\n    mapping(address => uint256) public userCollateralShare;\n\n    // Elastic: Exact asset token amount that currently needs to be repaid\n    // Base: Total parts of the debt held by borrowers (borrowerDebtPart)\n    Rebase public totalDebt;\n    mapping(address => uint256) public borrowerDebtPart;\n\n    address public lender;\n    mapping(address => bool) public approvedBorrowers;\n\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    uint256 public exchangeRate;\n\n    struct AccrueInfo {\n        uint64 lastAccrued;\n        uint64 INTEREST_PER_SECOND; // (in units of 1/10^18)\n        uint64 EXPIRATION;\n        uint16 COLLATERALIZATION_RATE_BPS;\n        uint16 LIQUIDATION_MULTIPLIER_BPS;\n        uint16 BORROW_OPENING_FEE_BPS;\n        bool LIQUIDATION_SEIZE_COLLATERAL;\n    }\n    AccrueInfo public accrueInfo;\n\n    uint256 private constant PROTOCOL_FEE_BPS = 1000; // 10%\n    uint256 private constant BPS = 10_000;\n    uint256 private constant EXCHANGE_RATE_PRECISION = 1e18;\n\n    /// @notice The constructor is only used for the initial master contract. Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    struct InitSettings {\n        IERC20 collateral;\n        IERC20 asset;\n        IOracle oracle;\n        bytes oracleData;\n        address lender;\n        address[] borrowers;\n        uint64 INTEREST_PER_SECOND;\n        uint64 EXPIRATION;\n        uint16 COLLATERALIZATION_RATE_BPS;\n        uint16 LIQUIDATION_MULTIPLIER_BPS;\n        uint16 BORROW_OPENING_FEE_BPS;\n        bool LIQUIDATION_SEIZE_COLLATERAL;\n    }\n\n    /// @notice Serves as the constructor for clones, as clones can't have a regular constructor\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"PrivatePool: already initialized\");\n\n        InitSettings memory settings = abi.decode(data, (InitSettings));\n        require(address(settings.collateral) != address(0), \"PrivatePool: bad pair\");\n        require(settings.LIQUIDATION_MULTIPLIER_BPS >= BPS, \"PrivatePool: negative liquidation bonus\");\n        require(settings.COLLATERALIZATION_RATE_BPS <= BPS, \"PrivatePool: bad collateralization rate\");\n\n        collateral = settings.collateral;\n        asset = settings.asset;\n        oracle = settings.oracle;\n        oracleData = settings.oracleData;\n        lender = settings.lender;\n\n        AccrueInfo memory _aI;\n        _aI.INTEREST_PER_SECOND = settings.INTEREST_PER_SECOND;\n        _aI.EXPIRATION = settings.EXPIRATION == 0 ? uint64(-1) : settings.EXPIRATION;\n        _aI.COLLATERALIZATION_RATE_BPS = settings.COLLATERALIZATION_RATE_BPS;\n        _aI.LIQUIDATION_MULTIPLIER_BPS = settings.LIQUIDATION_MULTIPLIER_BPS;\n        _aI.BORROW_OPENING_FEE_BPS = settings.BORROW_OPENING_FEE_BPS;\n        _aI.LIQUIDATION_SEIZE_COLLATERAL = settings.LIQUIDATION_SEIZE_COLLATERAL;\n        accrueInfo = _aI;\n\n        for (uint256 i = 0; i < settings.borrowers.length; i++) {\n            approvedBorrowers[settings.borrowers[i]] = true;\n        }\n    }\n\n    function setApprovedBorrowers(address borrower, bool approved) external onlyOwner {\n        approvedBorrowers[borrower] = approved;\n    }\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        Rebase memory _totalDebt = totalDebt;\n        if (_totalDebt.base == 0) {\n            return;\n        }\n        // No overflow:\n        // - _totalDebt.elastic is 128 bits\n        // - INTEREST_PER_SECOND is 64 bits\n        // - elapsedTime fits in 64 bits for the next 580 billion (10^9) years\n        uint256 extraAmount = (uint256(_totalDebt.elastic) * _accrueInfo.INTEREST_PER_SECOND * elapsedTime) / 1e18;\n\n        // If the interest rate is too high, then this will overflow and\n        // effectively lock up all funds. Do not set the interest rate too\n        // high.\n        _totalDebt.elastic = _totalDebt.elastic.add(extraAmount.to128());\n        totalDebt = _totalDebt;\n\n        // No overflow: extraAmount is divided by 1e18 > 2^59; we need 16 bits\n        uint256 feeAmount = (extraAmount * PROTOCOL_FEE_BPS) / BPS;\n\n        AssetBalance memory _assetBalance = assetBalance;\n        if (_assetBalance.reservesShare == 0) {\n            // Fees owed are always part of the debt, and the debt just got\n            // at least `feeAmount` added to it. If that fit, so does this:\n            feesOwedAmount += feeAmount;\n        } else {\n            uint256 feeShare = bentoBox.toShare(asset, feeAmount, false);\n            if (_assetBalance.reservesShare < feeShare) {\n                _assetBalance.feesEarnedShare += _assetBalance.reservesShare;\n                feesOwedAmount += bentoBox.toAmount(asset, feeShare - _assetBalance.reservesShare, false);\n                _assetBalance.reservesShare = 0;\n            } else {\n                // feesEarned + fee <= feesEarned + reserves <= Bento balance:\n                _assetBalance.reservesShare -= uint128(feeShare);\n                _assetBalance.feesEarnedShare += uint128(feeShare);\n            }\n            assetBalance = _assetBalance;\n        }\n\n        emit LogAccrue(extraAmount, feeAmount);\n    }\n\n    function _isSolvent(address borrower) internal returns (bool) {\n        (, uint256 _exchangeRate) = updateExchangeRate();\n\n        // accrue must have already been called!\n        uint256 debtPart = borrowerDebtPart[borrower];\n        if (debtPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[borrower];\n        if (collateralShare == 0) return false;\n\n        // The inequality that needs to hold for a user to be solvent is:\n        //\n        //    (value of user collateral) * (max LTV) >= (value of user debt)\n        //\n        // Our exchange rates give \"collateral per ether of asset\", so it makes\n        // sense to express the value in the collateral token. The calculation\n        // for the collateral value is:\n        //\n        //                                BentoBox tokens\n        //               value = shares * ---------------\n        //                                BentoBox shares\n        //\n        // where BentoBox tokens resp. shares refer to the balances for the\n        // collateral (ERC20) contract. For the debt we get:\n        //\n        //                  Total debt tokens   Collateral wei per asset ether\n        //  value = parts * ----------------- * ------------------------------\n        //                   Total debt parts               1e18\n        //\n        // ..since \"tokens\" is in wei. We call this EXCHANGE_RATE_PRECISION.\n        // Finally, max LTV is\n        //\n        //          COLLATERALIZATION_RATE_BPS\n        //  ratio = --------------------------.\n        //                     1e4\n        //\n        // We use the below table to (fit the inequality in 80 characters and)\n        // move some things around and justify our calculations.\n        //\n        //      Description                 Variable in contract        Bits\n        // -----------------------------------------------------------------\n        // cs   shares                      collateralShare             128*\n        // Be   BentoBox tokens             bentoBoxTotals.elastic      128\n        // Bb   BentoBox shares             bentoBoxTotals.base         128\n        // -----------------------------------------------------------------\n        // dp   parts                       debtPart                    128*\n        // De   Total debt tokens           totalDebt.elastic           128\n        // Db   Total debt parts            totalDebt.base              128\n        // xr   Coll. wei per asset ether   exchangeRate                256\n        //      1e18                        EXCHANGE_RATE_PRECISION      60\n        // ----------------------------------------------------------------\n        // ltv                              COLLATERALIZATION_RATE_BPS   14\n        //      1e4                         BPS                          14\n        //      1e14                                                     47\n        //\n        // (* as in other proofs, these values fit in some 128-bit total).\n        // The inequality, without regard for integer division:\n        //\n        //                       Be   ltv         De    xr\n        //                  cs * -- * --- >= dp * -- * ----\n        //                       Bb   1e4         Db   1e18\n        //\n        // This is equivalent to:\n        //\n        //    cs *  Be * ltv *  Db * 1e14 >=  dp *  De *  xr *  Bb\n        //\n        // Corresponding bit counts:\n        //\n        //   128 + 128 +  14 + 128 + 47;     128 + 128 + 256 + 128\n        //\n        // So, the LHS definitely fits in 512 bits, and as long as one token is\n        // not 2^68 times as valuable as another. Of course the other terms\n        // leave some leeway, too; if the exchange rate is this high, then the\n        // Bento share count is very unlikely to take up the full 128 bits.\n        //\n        // \"Full\" multiplication is not very expensive or cumbersome; the case\n        // where `exchangeRate` is too big is a little more involved, but\n        // manageable.\n\n        Rebase memory _totalDebt = totalDebt;\n        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);\n\n        (uint256 leftLo, uint256 leftHi) = FullMath.fullMul(\n            collateralShare * bentoBoxTotals.elastic,\n            // Cast needed to avoid uint128 overflow\n            uint256(accrueInfo.COLLATERALIZATION_RATE_BPS) * _totalDebt.base * 1e14\n        );\n        uint256 rightLo;\n        uint256 rightHi;\n        if (_exchangeRate <= type(uint128).max) {\n            (rightLo, rightHi) = FullMath.fullMul(debtPart * _totalDebt.elastic, _exchangeRate * bentoBoxTotals.base);\n        } else {\n            // We multiply it out in stages to be safe. If the total overflows\n            // 512 bits then we are done, as the LHS is guaranteed to be less.\n            //\n            //               aHi * 2^256 + aLo =                    dp * De * Bb\n            // -----------------------------------------------------------------\n            // The total is then the sum of:\n            //\n            // bHi * 2^512 + bLo * 2^256       = xr * aHi * 2^256\n            //               cHi * 2^256 + cLo = xr *               aLo\n            //\n            (uint256 aLo, uint256 aHi) = FullMath.fullMul(debtPart * _totalDebt.elastic, bentoBoxTotals.base);\n            (uint256 bLo, uint256 bHi) = FullMath.fullMul(_exchangeRate, aHi);\n            if (bHi > 0) {\n                return false;\n            }\n\n            uint256 cHi; // (cLo is rightLo)\n            (rightLo, cHi) = FullMath.fullMul(_exchangeRate, aLo);\n            rightHi = cHi + bLo;\n            if (rightHi < cHi) {\n                return false;\n            }\n        }\n        return leftHi > rightHi || (leftHi == rightHi && leftLo >= rightLo);\n    }\n\n    /// @dev Checks if the borrower is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent() {\n        _;\n        require(_isSolvent(msg.sender), \"PrivatePool: borrower insolvent\");\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(oracleData);\n\n        if (updated) {\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param token The ERC-20 token.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\n    function _addTokens(\n        IERC20 token,\n        uint256 share,\n        uint256 total,\n        bool skim\n    ) internal {\n        if (skim) {\n            require(share <= bentoBox.balanceOf(token, address(this)).sub(total), \"PrivatePool: skim too much\");\n        } else {\n            bentoBox.transfer(token, msg.sender, address(this), share);\n        }\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address to,\n        bool skim,\n        uint256 share\n    ) public {\n        uint256 supplied = userCollateralShare[to];\n        require(supplied > 0 || approvedBorrowers[to], \"PrivatePool: unapproved borrower\");\n\n        // No overflow: the total for ALL users fits in 128 bits, or the\n        // BentoBox transfer (_addTokens) fails.\n        userCollateralShare[to] = supplied + share;\n        CollateralBalance memory _collateralBalance = collateralBalance;\n        // No overflow: the sum fits in the BentoBox total\n        uint256 prevTotal = _collateralBalance.userTotalShare + _collateralBalance.feesEarnedShare;\n        // No overflow if cast safe: fits in the BentoBox or _addTokens reverts\n        // Cast safe: _addTokens does not truncate the value\n        collateralBalance.userTotalShare = _collateralBalance.userTotalShare + uint128(share);\n        _addTokens(collateral, share, prevTotal, skim);\n        emit LogAddCollateral(skim ? address(bentoBox) : msg.sender, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address to, uint256 share) internal {\n        userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);\n        // No underflow: userTotalShare > userCollateralShare[msg.sender]\n        // Cast safe: Bento transfer reverts if it is not.\n        collateralBalance.userTotalShare -= uint128(share);\n        emit LogRemoveCollateral(msg.sender, to, share);\n        bentoBox.transfer(collateral, address(this), to, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(address to, uint256 share) public solvent {\n        // accrue must be called because we check solvency\n        accrue();\n        _removeCollateral(to, share);\n    }\n\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// @param toReservesShare Amount of shares to reserves.\n    /// @param toReservesAmount Token amount. Ignored if `toReservesShare` nonzero.\n    /// @param toFeesAmount Token fee amount. Ignored if `toReservesShare` nonzero.\n    function _receiveAsset(\n        bool skim,\n        uint256 toReservesShare,\n        // (There is no case where we pass along a fee in shares)\n        uint256 toReservesAmount,\n        uint256 toFeesAmount\n    ) internal {\n        IERC20 _asset = asset;\n        AssetBalance memory _assetBalance = assetBalance;\n        uint256 priorAssetTotalShare = _assetBalance.reservesShare + _assetBalance.feesEarnedShare;\n        Rebase memory bentoBoxTotals = bentoBox.totals(_asset);\n\n        uint256 toFeesShare = 0;\n        if (toReservesShare == 0) {\n            toReservesShare = bentoBoxTotals.toBase(toReservesAmount, true);\n            if (toFeesAmount > 0) {\n                toFeesShare = bentoBoxTotals.toBase(toFeesAmount, false);\n            }\n        }\n        uint256 takenShare = toReservesShare.add(toFeesShare);\n\n        if (_assetBalance.reservesShare == 0) {\n            uint256 _feesOwedAmount = feesOwedAmount;\n            if (_feesOwedAmount > 0) {\n                uint256 feesOwedShare = bentoBoxTotals.toBase(_feesOwedAmount, false);\n                // New fees cannot pay off existing fees:\n                if (toReservesShare < feesOwedShare) {\n                    feesOwedAmount = bentoBoxTotals.toElastic(feesOwedShare - toReservesShare, false);\n                    _assetBalance.feesEarnedShare += uint128(takenShare);\n                } else {\n                    feesOwedAmount = 0;\n                    // No overflow: assuming the transfer at the end succeeds:\n                    //     feesOwedShare <= toReservesShare <= (Bento balance),\n                    _assetBalance.feesEarnedShare += uint128(feesOwedShare + toFeesShare);\n                    _assetBalance.reservesShare = uint128(toReservesShare - feesOwedShare);\n                }\n            } else {\n                _assetBalance.reservesShare = uint128(toReservesShare);\n                _assetBalance.feesEarnedShare += uint128(toFeesShare);\n            }\n        } else {\n            _assetBalance.reservesShare += uint128(toReservesShare);\n            _assetBalance.feesEarnedShare += uint128(toFeesShare);\n        }\n        assetBalance = _assetBalance;\n\n        _addTokens(_asset, takenShare, priorAssetTotalShare, skim);\n    }\n\n    /// @dev Concrete implementation of `addAsset`.\n    function _addAsset(bool skim, uint256 share) internal {\n        _receiveAsset(skim, share, 0, 0);\n        emit LogAddAsset(skim ? address(bentoBox) : msg.sender, share);\n    }\n\n    /// @notice Adds assets to the lending pair.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\n    /// @param share The amount of shares to add.\n    function addAsset(bool skim, uint256 share) public {\n        accrue();\n        _addAsset(skim, share);\n    }\n\n    /// @dev Concrete implementation of `removeAsset`.\n    function _removeAsset(address to, uint256 share) internal {\n        require(msg.sender == lender, \"PrivatePool: not the lender\");\n        // Cast safe: Bento transfer reverts unless stronger condition holds\n        assetBalance.reservesShare = assetBalance.reservesShare.sub(uint128(share));\n        bentoBox.transfer(asset, address(this), to, share);\n        emit LogRemoveAsset(to, share);\n    }\n\n    /// @notice Removes an asset from msg.sender and transfers it to `to`.\n    /// @param to The address that receives the removed assets.\n    /// @param share The amount of shares to remove.\n    function removeAsset(address to, uint256 share) public {\n        accrue();\n        _removeAsset(to, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        require(approvedBorrowers[msg.sender], \"PrivatePool: unapproved borrower\");\n        IERC20 _asset = asset;\n        Rebase memory bentoBoxTotals = bentoBox.totals(_asset);\n        AccrueInfo memory _accrueInfo = accrueInfo;\n\n        share = bentoBoxTotals.toBase(amount, false);\n\n        // No overflow: `share` is not modified any more, and fits in the\n        // BentoBox shares total if the transfer succeeds. But then \"amount\"\n        // must fit in the token total; at least up to some rounding error,\n        // which cannot be more than 128 bits either.\n        uint256 openFeeAmount = (amount * _accrueInfo.BORROW_OPENING_FEE_BPS) / BPS;\n        // No overflow: Same reason. Also, we just divided by BPS..\n        uint256 protocolFeeAmount = (openFeeAmount * PROTOCOL_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = bentoBoxTotals.toBase(protocolFeeAmount, false);\n\n        // The protocol component of the opening fee cannot be owed:\n        AssetBalance memory _assetBalance = assetBalance;\n        // No overflow on the add: protocolFeeShare < share < Bento total, or\n        // the transfer reverts. The transfer is independent of the results of\n        // these calculations: `share` is not modified.\n        // Theoretically the fee could just make it overflow 128 bits.\n        // Underflow check is core business logic:\n        _assetBalance.reservesShare = _assetBalance.reservesShare.sub((share + protocolFeeShare).to128());\n        // Cast is safe: `share` fits. Also, the checked cast above succeeded.\n        // No overflow: protocolFeeShare < reservesShare, and both balances\n        // together fit in the Bento share balance,\n        _assetBalance.feesEarnedShare += uint128(protocolFeeShare);\n        assetBalance = _assetBalance;\n\n        // No overflow (inner add): amount fits in 128 bits, as shown before,\n        // and openFeeAmount is less.\n        (totalDebt, part) = totalDebt.add(amount + openFeeAmount, true);\n        // No overflow: totalDebt.base is the sum of all borrowerDebtParts,\n        //              fits in 128 bits and just had \"part\" added to it.\n        borrowerDebtPart[msg.sender] += part;\n        emit LogBorrow(msg.sender, to, amount, openFeeAmount, part);\n\n        bentoBox.transfer(_asset, address(this), to, share);\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {\n        accrue();\n        (part, share) = _borrow(to, amount);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(\n        address to,\n        bool skim,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalDebt, amount) = totalDebt.sub(part, true);\n        borrowerDebtPart[to] = borrowerDebtPart[to].sub(part);\n        _receiveAsset(skim, 0, amount, 0);\n        emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);\n    }\n\n    /// @notice Repays a loan.\n    /// @param to Address of the borrower this payment should go.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\n    /// @param part The amount to repay as part. See `borrowerDebtPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address to,\n        bool skim,\n        uint256 part\n    ) public returns (uint256 amount) {\n        accrue();\n        amount = _repay(to, skim, part);\n    }\n\n    // Functions that need accrue to be called\n    uint8 internal constant ACTION_ADD_ASSET = 1;\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_ASSET = 3;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n    uint8 internal constant ACTION_BORROW = 5;\n    uint8 internal constant ACTION_GET_REPAY_SHARE = 6;\n    uint8 internal constant ACTION_GET_REPAY_PART = 7;\n    uint8 internal constant ACTION_ACCRUE = 8;\n\n    // Functions that don't need accrue to be called\n    uint8 internal constant ACTION_ADD_COLLATERAL = 10;\n    uint8 internal constant ACTION_UPDATE_EXCHANGE_RATE = 11;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` are not allowed for obvious security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(this), \"PrivatePool: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"PrivatePool: call failed\");\n        return (returnData, returnValues);\n    }\n\n    struct CookStatus {\n        bool needsSolvencyCheck;\n        bool hasAccrued;\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        CookStatus memory status;\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (!status.hasAccrued && action < 10) {\n                accrue();\n                status.hasAccrued = true;\n            }\n            if (action == ACTION_ADD_COLLATERAL) {\n                (int256 share, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\n                addCollateral(to, skim, _num(share, value1, value2));\n            } else if (action == ACTION_ADD_ASSET) {\n                (int256 share, bool skim) = abi.decode(datas[i], (int256, bool));\n                _addAsset(skim, _num(share, value1, value2));\n            } else if (action == ACTION_REPAY) {\n                (int256 part, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\n                _repay(to, skim, _num(part, value1, value2));\n            } else if (action == ACTION_REMOVE_ASSET) {\n                (int256 share, address to) = abi.decode(datas[i], (int256, address));\n                _removeAsset(to, _num(share, value1, value2));\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (int256 share, address to) = abi.decode(datas[i], (int256, address));\n                _removeCollateral(to, _num(share, value1, value2));\n                status.needsSolvencyCheck = true;\n            } else if (action == ACTION_BORROW) {\n                (int256 amount, address to) = abi.decode(datas[i], (int256, address));\n                (value1, value2) = _borrow(to, _num(amount, value1, value2));\n                status.needsSolvencyCheck = true;\n            } else if (action == ACTION_UPDATE_EXCHANGE_RATE) {\n                (bool must_update, uint256 minRate, uint256 maxRate) = abi.decode(datas[i], (bool, uint256, uint256));\n                (bool updated, uint256 rate) = updateExchangeRate();\n                require((!must_update || updated) && rate > minRate && (maxRate == 0 || rate > maxRate), \"PrivatePool: rate not ok\");\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_GET_REPAY_SHARE) {\n                int256 part = abi.decode(datas[i], (int256));\n                value1 = bentoBox.toShare(asset, totalDebt.toElastic(_num(part, value1, value2), true), true);\n            } else if (action == ACTION_GET_REPAY_PART) {\n                int256 amount = abi.decode(datas[i], (int256));\n                value1 = totalDebt.toBase(_num(amount, value1, value2), false);\n            }\n        }\n\n        if (status.needsSolvencyCheck) {\n            require(_isSolvent(msg.sender), \"PrivatePool: borrower insolvent\");\n        }\n    }\n\n    /// @notice Handles the liquidation of borrowers' balances, once the borrowers' amount of collateral is too low.\n    /// @param borrowers An array of borrower addresses.\n    /// @param maxDebtParts A one-to-one mapping to `borrowers`, contains maximum part (not token amount) of the debt that will be liquidated of the respective borrower.\n    /// @param to Address of the receiver if `swapper` is zero.\n    /// @param swapper Contract address of the `ISimpleSwapper` implementation.\n    function liquidate(\n        address[] calldata borrowers,\n        uint256[] calldata maxDebtParts,\n        address to,\n        ISimpleSwapper swapper\n    ) public {\n        // Oracle can fail but we still need to allow liquidations\n        (, uint256 _exchangeRate) = updateExchangeRate();\n        accrue();\n\n        AccrueInfo memory _accrueInfo = accrueInfo;\n\n        uint256 allCollateralShare;\n        uint256 allDebtAmount;\n        uint256 allDebtPart;\n        Rebase memory _totalDebt = totalDebt;\n        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);\n\n        for (uint256 i = 0; i < borrowers.length; i++) {\n            // TODO: Find a way to not have it here; only for stack reasons\n            address borrower = borrowers[i];\n            // If we set an expiration at all, then by the above check it is\n            // now past and every borrower can be liquidated at the current\n            // price:\n            if (block.timestamp >= accrueInfo.EXPIRATION || !_isSolvent(borrower)) {\n                uint256 debtPart;\n                {\n                    uint256 availableDebtPart = borrowerDebtPart[borrower];\n                    debtPart = maxDebtParts[i] > availableDebtPart ? availableDebtPart : maxDebtParts[i];\n                    // No underflow: ensured by definition of debtPart\n                    borrowerDebtPart[borrower] = availableDebtPart - debtPart;\n                }\n                uint256 debtAmount = _totalDebt.toElastic(debtPart, false);\n                // No overflow (inner): debtAmount <= totalDebt.elastic < 2^128.\n                // The exchange rate need not be reasonable: with an expiration\n                // time set there is no _isSolvent() call.\n                uint256 collateralShare = bentoBoxTotals.toBase(\n                    (debtAmount * _accrueInfo.LIQUIDATION_MULTIPLIER_BPS).mul(_exchangeRate) / (BPS * EXCHANGE_RATE_PRECISION),\n                    false\n                );\n\n                // This needs to be updated here so that the same user cannot\n                // be liquidated more than once. (Unless it adds up to one\n                // \"full\" liquidation or less).\n                // Underflow check is business logic: the liquidator can only\n                // take enough to cover the loan (and bonus).\n                userCollateralShare[borrower] = userCollateralShare[borrower].sub(collateralShare);\n\n                if (_accrueInfo.LIQUIDATION_SEIZE_COLLATERAL) {\n                    emit LogSeizeCollateral(borrower, collateralShare, debtAmount, debtPart);\n                } else {\n                    emit LogRemoveCollateral(borrower, swapper == ISimpleSwapper(0) ? to : address(swapper), collateralShare);\n                    emit LogRepay(swapper == ISimpleSwapper(0) ? msg.sender : address(swapper), borrower, debtAmount, debtPart);\n                }\n\n                // No overflow in the below three:\n                //\n                // share(s) / amount(s) / part(s) involved in liquidation\n                //      <= total share / amount / part\n                //      <= (Bento).base / totalDebt.elastic / totalDebt.base\n                //      <  2^128\n                //\n                // Collateral share and debt part have already been\n                // successfully subtracted from some user's balance (and this\n                // persists across loop runs); the calculation for debt amount\n                // rounds down, so it fits if debtPart fits. It follows that\n                // the condition holds for the accumulated sums.\n                allCollateralShare += collateralShare;\n                allDebtAmount += debtAmount;\n                allDebtPart += debtPart;\n            }\n        }\n        require(allDebtAmount != 0, \"PrivatePool: all are solvent\");\n        // No overflow (both): (liquidated debt) <= (total debt).\n        // Cast is safe (both): (liquidated debt) <= (total debt) < 2^128\n        _totalDebt.elastic -= uint128(allDebtAmount);\n        _totalDebt.base -= uint128(allDebtPart);\n        totalDebt = _totalDebt;\n\n        if (_accrueInfo.LIQUIDATION_SEIZE_COLLATERAL) {\n            // Unlike normal liquidations, the liquidator and the lender share\n            // the excess. This compensates the lender for agreeing to payment\n            // in the collateral. The protocol gets a cut of the total excess.\n            // So the final distribution is\n            // - X% excess (configurable via LIQUIDATION_MULTIPLIER_BPS)\n            // - (10% of X) protocol fee\n            // - (45% of X) liquidator share of bonus\n            // - 100% + (45% of X) debt + lender share of bonus\n            // allCollateralShare already includes the bonus, which in turn\n            // includes the protocol fee. We round the bonus down to favor the\n            // lender, and the fee to favor the liquidator and lender:\n            // Math: All collateral fits in 128 bits (BentoBox), so the\n            // multiplications are safe:\n            uint256 excessShare = (allCollateralShare * (_accrueInfo.LIQUIDATION_MULTIPLIER_BPS - BPS)) /\n                _accrueInfo.LIQUIDATION_MULTIPLIER_BPS;\n            uint256 feeShare = (excessShare * PROTOCOL_FEE_BPS) / BPS;\n            uint256 liquidatorShare = (excessShare - feeShare) / 2;\n            // We would add more variables for clarity, but stack depth:\n            {\n                CollateralBalance memory _collateralBalance = collateralBalance;\n                // No underflow: All amounts fit in the collateral Bento total\n                // The lender is also a \"user\", so only the fee and liquidator\n                // share leave the user total \"account\":\n                _collateralBalance.userTotalShare -= uint128(feeShare + liquidatorShare);\n                _collateralBalance.feesEarnedShare += uint128(feeShare);\n                collateralBalance = _collateralBalance;\n            }\n            // The rest goes to the lender:\n            userCollateralShare[lender] += (allCollateralShare - feeShare - liquidatorShare);\n            // The liquidator gets the other half -- rounded in their favour,\n            // if applicable:\n            bentoBox.transfer(collateral, address(this), to, liquidatorShare);\n        } else {\n            // No underflow: allCollateralShare is the sum of quantities that\n            //               have successfully been taken out of user balances.\n            // Cast is safe: Above reason, and userTotalShare < 2^128\n            collateralBalance.userTotalShare -= uint128(allCollateralShare);\n\n            // Charge the protocol fee over the excess.\n            // No overflow:\n            //  allDebtAmount <= totalDebt.elastic < 2^128 (proof in loop)\n            //  LIQUIDATION_MULTIPLIER_BPS < 2^16\n            //  PROTOCOL_FEE_BPS <= 10k < 2^14 (or we have bigger problems)\n            uint256 feeAmount = (allDebtAmount * (_accrueInfo.LIQUIDATION_MULTIPLIER_BPS - BPS) * PROTOCOL_FEE_BPS) / (BPS * BPS);\n\n            // Swap using a swapper freely chosen by the caller\n            // Open (flash) liquidation: get proceeds first and provide the\n            // borrow after\n            bentoBox.transfer(collateral, address(this), swapper == ISimpleSwapper(0) ? to : address(swapper), allCollateralShare);\n            if (swapper != ISimpleSwapper(0)) {\n                // TODO: Somehow split _receiveAsset to reduce loads?\n                IERC20 _asset = asset;\n                swapper.swap(\n                    collateral,\n                    _asset,\n                    msg.sender,\n                    bentoBox.toShare(_asset, allDebtAmount.add(feeAmount), true),\n                    allCollateralShare\n                );\n            }\n            _receiveAsset(false, 0, allDebtAmount, feeAmount);\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        accrue();\n        address to = masterContract.feeTo();\n\n        uint256 assetShare = assetBalance.feesEarnedShare;\n        if (assetShare > 0) {\n            bentoBox.transfer(asset, address(this), to, assetShare);\n            assetBalance.feesEarnedShare = 0;\n        }\n\n        uint256 collateralShare = collateralBalance.feesEarnedShare;\n        if (collateralShare > 0) {\n            bentoBox.transfer(collateral, address(this), to, collateralShare);\n            collateralBalance.feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, assetShare, collateralShare);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n"
    },
    "contracts/interfaces/ISimpleSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\n\ninterface ISimpleSwapper {\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for at least 'amountToMin' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n}\n"
    },
    "contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity 0.6.12;\n\n// solhint-disable\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n        require(h < d, \"FullMath::mulDiv: overflow\");\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.12;\nimport \"./FullMath.sol\";\n\n// solhint-disable\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint256, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, \"FixedPoint::mul: overflow\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // lossy if either numerator or denominator is greater than 112 bits\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint::fraction: div by 0\");\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), \"FixedPoint::fraction: overflow\");\n            return uq112x112(uint224(result));\n        }\n    }\n}\n"
    },
    "contracts/oracles/xJOEOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Using the same Copyleft License as in the original Repository\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"../interfaces/IOracle.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../libraries/FixedPoint.sol\";\n\nimport \"hardhat/console.sol\";\n\n// solhint-disable not-rely-on-time\n\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ncontract XJoeOracleV2 is IOracle {\n    using FixedPoint for *;\n    using BoringMath for uint256;\n    uint256 public constant PERIOD = 10 minutes;\n    IAggregator public constant AVAX_USD = IAggregator(0x0A77230d17318075983913bC2145DB16C7366156);\n    IUniswapV2Pair public constant JOE_AVAX = IUniswapV2Pair(0x454E67025631C065d3cFAD6d71E6892f74487a15);\n    IERC20 public constant JOE = IERC20(0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd);\n    IERC20 public constant XJOE = IERC20(0x57319d41F71E81F3c65F2a47CA4e001EbAFd4F33);\n\n    struct PairInfo {\n        uint256 priceCumulativeLast;\n        uint32 blockTimestampLast;\n        uint144 priceAverage;\n    }\n\n    PairInfo public pairInfo;\n    function _get(uint32 blockTimestamp) public view returns (uint256) {\n        uint256 priceCumulative = JOE_AVAX.price0CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(JOE_AVAX).getReserves();\n        priceCumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        return priceCumulative;\n    }\n\n    function toXJOE(uint256 amount) internal view returns (uint256) {\n        return amount.mul(JOE.balanceOf(address(XJOE))) / XJOE.totalSupply();\n    }\n\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\n    /// @inheritdoc IOracle\n    function get(bytes calldata) external override returns (bool, uint256) {\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairInfo.blockTimestampLast == 0) {\n            pairInfo.blockTimestampLast = blockTimestamp;\n            pairInfo.priceCumulativeLast = _get(blockTimestamp);\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairInfo.blockTimestampLast; // overflow is desired\n              console.log(timeElapsed);\n        if (timeElapsed < PERIOD) {\n            return (true, pairInfo.priceAverage);\n        }\n\n        uint256 priceCumulative = _get(blockTimestamp);\n        pairInfo.priceAverage = uint144(1e44 / toXJOE(uint256(FixedPoint\n            .uq112x112(uint224((priceCumulative - pairInfo.priceCumulativeLast) / timeElapsed))\n            .mul(1e18)\n            .decode144())).mul(uint256(AVAX_USD.latestAnswer())));\n        pairInfo.blockTimestampLast = blockTimestamp;\n        pairInfo.priceCumulativeLast = priceCumulative;\n\n        return (true, pairInfo.priceAverage);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairInfo.blockTimestampLast == 0) {\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairInfo.blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairInfo.priceAverage);\n        }\n\n        uint256 priceCumulative = _get(blockTimestamp);\n        uint144 priceAverage = uint144(1e44 / toXJOE(uint256(FixedPoint\n            .uq112x112(uint224((priceCumulative - pairInfo.priceCumulativeLast) / timeElapsed))\n            .mul(1e18)\n            .decode144())).mul(uint256(AVAX_USD.latestAnswer())));\n\n        return (true, priceAverage);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata) external view override returns (uint256 rate) {\n        (uint256 reserve0, uint256 reserve1, ) = JOE_AVAX.getReserves();\n        rate = 1e44 / toXJOE(reserve1.mul(1e18) / reserve0).mul(uint256(AVAX_USD.latestAnswer()));\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"xJOE TWAP\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"xJOE\";\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/oracles/YearnChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256 price);\n}\n\ncontract YearnChainlinkOracle is IOracle {\n    using BoringMath for uint256; // Keep everything in uint256\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get(\n        address multiply,\n        address divide,\n        uint256 decimals,\n        address yearnVault\n    ) internal view returns (uint256) {\n        uint256 price = uint256(1e36);\n        if (multiply != address(0)) {\n            price = price.mul(uint256(IAggregator(multiply).latestAnswer()));\n        } else {\n            price = price.mul(1e18);\n        }\n\n        if (divide != address(0)) {\n            price = price / uint256(IAggregator(divide).latestAnswer());\n        }\n\n        // @note decimals have to take into account the decimals of the vault asset\n        return price / decimals.mul(IYearnVault(yearnVault).pricePerShare());\n    }\n\n    function getDataParameter(\n        address multiply,\n        address divide,\n        uint256 decimals,\n        address yearnVault\n    ) public pure returns (bytes memory) {\n        return abi.encode(multiply, divide, decimals, yearnVault);\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) public override returns (bool, uint256) {\n        (address multiply, address divide, uint256 decimals, address yearnVault) = abi.decode(data, (address, address, uint256, address));\n        return (true, _get(multiply, divide, decimals, yearnVault));\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        (address multiply, address divide, uint256 decimals, address yearnVault) = abi.decode(data, (address, address, uint256, address));\n        return (true, _get(multiply, divide, decimals, yearnVault));\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"Chainlink\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"LINK\";\n    }\n}\n"
    },
    "contracts/oracles/xSUSHIOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IOracle.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\n/// @title xSUSHIOracle\n/// @author BoringCrypto\n/// @notice Oracle used for getting the price of xSUSHI based on Chainlink\n/// @dev\ncontract xSUSHIOracle is IOracle {\n    using BoringMath for uint256; // Keep everything in uint256\n\n    IERC20 public immutable sushi;\n    IERC20 public immutable bar;\n    IAggregator public immutable sushiOracle;\n\n    constructor(\n        IERC20 sushi_,\n        IERC20 bar_,\n        IAggregator sushiOracle_\n    ) public {\n        sushi = sushi_;\n        bar = bar_;\n        sushiOracle = sushiOracle_;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses sushi rate and xSUSHI conversion and divide for any conversion other than from SUSHI to ETH\n    function _get(address divide, uint256 decimals) internal view returns (uint256) {\n        uint256 price = uint256(1e36);\n        price = (price.mul(uint256(sushiOracle.latestAnswer())) / bar.totalSupply()).mul(sushi.balanceOf(address(bar)));\n\n        if (divide != address(0)) {\n            price = price / uint256(IAggregator(divide).latestAnswer());\n        }\n\n        return price / decimals;\n    }\n\n    function getDataParameter(address divide, uint256 decimals) public pure returns (bytes memory) {\n        return abi.encode(divide, decimals);\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) public override returns (bool, uint256) {\n        (address divide, uint256 decimals) = abi.decode(data, (address, uint256));\n        return (true, _get(divide, decimals));\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        (address divide, uint256 decimals) = abi.decode(data, (address, uint256));\n        return (true, _get(divide, decimals));\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"xSUSHI Chainlink\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"xSUSHI-LINK\";\n    }\n}\n"
    },
    "contracts/oracles/wOHMLinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IWOHM {\n    function sOHMTowOHM( uint256 _amount ) external view returns ( uint256 );\n}\n\ncontract wOHMOracle is IOracle {\n    using BoringMath for uint256; // Keep everything in uint256\n\n    IAggregator public constant ohmOracle = IAggregator(0x90c2098473852E2F07678Fe1B6d595b1bd9b16Ed);\n    IAggregator public constant ethUSDOracle = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    IWOHM public constant WOHM = IWOHM(0xCa76543Cf381ebBB277bE79574059e32108e3E65);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e44 / (uint256(1e18).mul(uint256(ohmOracle.latestAnswer()).mul(uint256(ethUSDOracle.latestAnswer()))) / WOHM.sOHMTowOHM(1e9));\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata ) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"wOHM Chainlink\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"LINK/wOHM\";\n    }\n}\n"
    },
    "contracts/oracles/wMEMOOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Using the same Copyleft License as in the original Repository\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"../interfaces/IOracle.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../libraries/FixedPoint.sol\";\n\n// solhint-disable not-rely-on-time\n\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ninterface IWMEMO {\n    function MEMOTowMEMO( uint256 _amount ) external view returns ( uint256 );\n}\n\ncontract wMemoOracle is IOracle {\n    using FixedPoint for *;\n    using BoringMath for uint256;\n    uint256 public constant PERIOD = 10 minutes;\n    IAggregator public constant MIM_USD = IAggregator(0x54EdAB30a7134A16a54218AE64C73e1DAf48a8Fb);\n    IUniswapV2Pair public constant WMEMO_MIM = IUniswapV2Pair(0x4d308C46EA9f234ea515cC51F16fba776451cac8);\n\n    IWMEMO public constant WMEMO = IWMEMO(0x0da67235dD5787D67955420C84ca1cEcd4E5Bb3b);\n\n    struct PairInfo {\n        uint256 priceCumulativeLast;\n        uint32 blockTimestampLast;\n        uint144 priceAverage;\n    }\n\n    PairInfo public pairInfo;\n    function _get(uint32 blockTimestamp) public view returns (uint256) {\n        uint256 priceCumulative = WMEMO_MIM.price0CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(WMEMO_MIM).getReserves();\n        priceCumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        return priceCumulative;\n    }\n\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) external override returns (bool, uint256) {\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairInfo.blockTimestampLast == 0) {\n            pairInfo.blockTimestampLast = blockTimestamp;\n            pairInfo.priceCumulativeLast = _get(blockTimestamp);\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairInfo.blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairInfo.priceAverage);\n        }\n\n        uint256 priceCumulative = _get(blockTimestamp);\n        pairInfo.priceAverage = uint144(1e44 / uint256(FixedPoint\n            .uq112x112(uint224((priceCumulative - pairInfo.priceCumulativeLast) / timeElapsed))\n            .mul(1e18)\n            .decode144()).mul(uint256(MIM_USD.latestAnswer())));\n        pairInfo.blockTimestampLast = blockTimestamp;\n        pairInfo.priceCumulativeLast = priceCumulative;\n\n        return (true, pairInfo.priceAverage);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairInfo.blockTimestampLast == 0) {\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairInfo.blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairInfo.priceAverage);\n        }\n\n        uint256 priceCumulative = _get(blockTimestamp);\n        uint144 priceAverage = uint144(1e44 / uint256(FixedPoint\n            .uq112x112(uint224((priceCumulative - pairInfo.priceCumulativeLast) / timeElapsed))\n            .mul(1e18)\n            .decode144()).mul(uint256(MIM_USD.latestAnswer())));\n\n        return (true, priceAverage);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (uint256 reserve0, uint256 reserve1, ) = WMEMO_MIM.getReserves();\n        rate = 1e44 / (reserve1.mul(1e18) / reserve0).mul(uint256(MIM_USD.latestAnswer()));\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"wMEMO TWAP\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"wMEMO\";\n    }\n}\n"
    },
    "contracts/oracles/SpellTWAPOracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Using the same Copyleft License as in the original Repository\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"../interfaces/IOracle.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"../libraries/FixedPoint.sol\";\n\n// solhint-disable not-rely-on-time\n\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ncontract SpellTWAPOracle is IOracle {\n    using FixedPoint for *;\n    using BoringMath for uint256;\n    uint256 public constant PERIOD = 10 minutes;\n    IAggregator public constant ETH_USD = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    IUniswapV2Pair public constant pair = IUniswapV2Pair(0xb5De0C3753b6E1B4dBA616Db82767F17513E6d4E);\n\n    IERC20 public constant SSPELL = IERC20(0x26FA3fFFB6EfE8c1E69103aCb4044C26B9A106a9);\n    IERC20 public constant SPELL = IERC20(0x090185f2135308BaD17527004364eBcC2D37e5F6);\n\n    struct PairInfo {\n        uint256 priceCumulativeLast;\n        uint32 blockTimestampLast;\n        uint144 priceAverage;\n    }\n\n    PairInfo public pairInfo;\n    function _get(uint32 blockTimestamp) public view returns (uint256) {\n        uint256 priceCumulative = pair.price0CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        priceCumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        return priceCumulative;\n    }\n\n    function toSSpell(uint256 amount) internal view returns (uint256) {\n        return amount.mul(SPELL.balanceOf(address(SSPELL))) / SSPELL.totalSupply();\n    }\n\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) external override returns (bool, uint256) {\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairInfo.blockTimestampLast == 0) {\n            pairInfo.blockTimestampLast = blockTimestamp;\n            pairInfo.priceCumulativeLast = _get(blockTimestamp);\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairInfo.blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairInfo.priceAverage);\n        }\n\n        uint256 priceCumulative = _get(blockTimestamp);\n        pairInfo.priceAverage = uint144(1e44 / toSSpell(uint256(FixedPoint\n            .uq112x112(uint224((priceCumulative - pairInfo.priceCumulativeLast) / timeElapsed))\n            .mul(1e18)\n            .decode144())).mul(uint256(ETH_USD.latestAnswer())));\n        pairInfo.blockTimestampLast = blockTimestamp;\n        pairInfo.priceCumulativeLast = priceCumulative;\n\n        return (true, pairInfo.priceAverage);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairInfo.blockTimestampLast == 0) {\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairInfo.blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairInfo.priceAverage);\n        }\n\n        uint256 priceCumulative = _get(blockTimestamp);\n        uint144 priceAverage = uint144(1e44 / toSSpell(uint256(FixedPoint\n            .uq112x112(uint224((priceCumulative - pairInfo.priceCumulativeLast) / timeElapsed))\n            .mul(1e18)\n            .decode144())).mul(uint256(ETH_USD.latestAnswer())));\n\n        return (true, priceAverage);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        rate = 1e44 / toSSpell(reserve1.mul(1e18) / reserve0).mul(uint256(ETH_USD.latestAnswer()));\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"SSpell TWAP CHAINLINK\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"SSpell\";\n    }\n}\n"
    },
    "contracts/oracles/SimpleSLPTWAP1Oracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Using the same Copyleft License as in the original Repository\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"../interfaces/IOracle.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../libraries/FixedPoint.sol\";\n\n// solhint-disable not-rely-on-time\n\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\n\ncontract SimpleSLPTWAP1Oracle is IOracle {\n    using FixedPoint for *;\n    using BoringMath for uint256;\n    uint256 public constant PERIOD = 5 minutes;\n\n    struct PairInfo {\n        uint256 priceCumulativeLast;\n        uint32 blockTimestampLast;\n        uint144 priceAverage;\n    }\n\n    mapping(IUniswapV2Pair => PairInfo) public pairs; // Map of pairs and their info\n    mapping(address => IUniswapV2Pair) public callerInfo; // Map of callers to pairs\n\n    function _get(IUniswapV2Pair pair, uint32 blockTimestamp) public view returns (uint256) {\n        uint256 priceCumulative = pair.price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        priceCumulative += uint256(FixedPoint.fraction(reserve0, reserve1)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        return priceCumulative;\n    }\n\n    function getDataParameter(IUniswapV2Pair pair) public pure returns (bytes memory) {\n        return abi.encode(pair);\n    }\n\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) external override returns (bool, uint256) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairs[pair].blockTimestampLast == 0) {\n            pairs[pair].blockTimestampLast = blockTimestamp;\n            pairs[pair].priceCumulativeLast = _get(pair, blockTimestamp);\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairs[pair].priceAverage);\n        }\n\n        uint256 priceCumulative = _get(pair, blockTimestamp);\n        pairs[pair].priceAverage = FixedPoint\n            .uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed))\n            .mul(10**18)\n            .decode144();\n        pairs[pair].blockTimestampLast = blockTimestamp;\n        pairs[pair].priceCumulativeLast = priceCumulative;\n\n        return (true, pairs[pair].priceAverage);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairs[pair].blockTimestampLast == 0) {\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairs[pair].priceAverage);\n        }\n\n        uint256 priceCumulative = _get(pair, blockTimestamp);\n        uint144 priceAverage =\n            FixedPoint.uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed)).mul(10**18).decode144();\n\n        return (true, priceAverage);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        rate = reserve0.mul(1e18) / reserve1;\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"SushiSwap TWAP\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"S\";\n    }\n}\n"
    },
    "contracts/oracles/SimpleSLPTWAP0Oracle.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Using the same Copyleft License as in the original Repository\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"../interfaces/IOracle.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../libraries/FixedPoint.sol\";\n\n// solhint-disable not-rely-on-time\n\n// adapted from https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/examples/ExampleSlidingWindowOracle.sol\n\ncontract SimpleSLPTWAP0Oracle is IOracle {\n    using FixedPoint for *;\n    using BoringMath for uint256;\n    uint256 public constant PERIOD = 5 minutes;\n\n    struct PairInfo {\n        uint256 priceCumulativeLast;\n        uint32 blockTimestampLast;\n        uint144 priceAverage;\n    }\n\n    mapping(IUniswapV2Pair => PairInfo) public pairs; // Map of pairs and their info\n    mapping(address => IUniswapV2Pair) public callerInfo; // Map of callers to pairs\n\n    function _get(IUniswapV2Pair pair, uint32 blockTimestamp) public view returns (uint256) {\n        uint256 priceCumulative = pair.price0CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        priceCumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * (blockTimestamp - blockTimestampLast); // overflows ok\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        return priceCumulative;\n    }\n\n    function getDataParameter(IUniswapV2Pair pair) public pure returns (bytes memory) {\n        return abi.encode(pair);\n    }\n\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) external override returns (bool, uint256) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairs[pair].blockTimestampLast == 0) {\n            pairs[pair].blockTimestampLast = blockTimestamp;\n            pairs[pair].priceCumulativeLast = _get(pair, blockTimestamp);\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairs[pair].priceAverage);\n        }\n\n        uint256 priceCumulative = _get(pair, blockTimestamp);\n        pairs[pair].priceAverage = FixedPoint\n            .uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed))\n            .mul(1e18)\n            .decode144();\n        pairs[pair].blockTimestampLast = blockTimestamp;\n        pairs[pair].priceCumulativeLast = priceCumulative;\n\n        return (true, pairs[pair].priceAverage);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        uint32 blockTimestamp = uint32(block.timestamp);\n        if (pairs[pair].blockTimestampLast == 0) {\n            return (false, 0);\n        }\n        uint32 timeElapsed = blockTimestamp - pairs[pair].blockTimestampLast; // overflow is desired\n        if (timeElapsed < PERIOD) {\n            return (true, pairs[pair].priceAverage);\n        }\n\n        uint256 priceCumulative = _get(pair, blockTimestamp);\n        uint144 priceAverage =\n            FixedPoint.uq112x112(uint224((priceCumulative - pairs[pair].priceCumulativeLast) / timeElapsed)).mul(1e18).decode144();\n\n        return (true, priceAverage);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        IUniswapV2Pair pair = abi.decode(data, (IUniswapV2Pair));\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        rate = reserve1.mul(1e18) / reserve0;\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"SushiSwap TWAP\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"S\";\n    }\n}\n"
    },
    "contracts/oracles/ProxyOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"../interfaces/IOracle.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\n\n/// @title ProxyOracle\n/// @author 0xMerlin\n/// @notice Oracle used for getting the price of xSUSHI based on Chainlink\ncontract ProxyOracle is IOracle, BoringOwnable {\n\n    IOracle public oracleImplementation;\n\n    event LogOracleImplementationChange(IOracle indexed oldOracle, IOracle indexed newOracle);\n\n    constructor() public {\n    }\n\n    function changeOracleImplementation(IOracle newOracle) external onlyOwner {\n        IOracle oldOracle = oracleImplementation;\n        oracleImplementation = newOracle;\n        emit LogOracleImplementationChange(oldOracle, newOracle);\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) public override returns (bool, uint256) {\n        return oracleImplementation.get(data);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        return oracleImplementation.peek(data);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        return oracleImplementation.peekSpot(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"Proxy Oracle\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"Proxy\";\n    }\n}\n"
    },
    "contracts/oracles/PeggedOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IOracle.sol\";\n\n/// @title PeggedOracle\n/// @author BoringCrypto\n/// @notice Oracle used for pegged prices that don't change\n/// @dev\ncontract PeggedOracle is IOracle {\n    /// @notice\n    /// @dev\n    /// @param rate (uint256) The fixed exchange rate\n    /// @return  (bytes)\n    function getDataParameter(uint256 rate) public pure returns (bytes memory) {\n        return abi.encode(rate);\n    }\n\n    // Get the exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) public override returns (bool, uint256) {\n        uint256 rate = abi.decode(data, (uint256));\n        return (rate != 0, rate);\n    }\n\n    // Check the exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        uint256 rate = abi.decode(data, (uint256));\n        return (rate != 0, rate);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"Pegged\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"PEG\";\n    }\n}\n"
    },
    "contracts/oracles/dQuickOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"../interfaces/IOracle.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\n/// @title xSUSHIOracle\n/// @author BoringCrypto\n/// @notice Oracle used for getting the price of xSUSHI based on Chainlink\n/// @dev\ncontract xSUSHIOracle is IOracle {\n    using BoringMath for uint256; // Keep everything in uint256\n\n    IERC20 public immutable sushi;\n    IERC20 public immutable bar;\n    IAggregator public immutable sushiOracle;\n\n    constructor(\n        IERC20 sushi_,\n        IERC20 bar_,\n        IAggregator sushiOracle_\n    ) public {\n        sushi = sushi_;\n        bar = bar_;\n        sushiOracle = sushiOracle_;\n    }\n\n    // Calculates the lastest exchange rate\n    // Uses sushi rate and xSUSHI conversion and divide for any conversion other than from SUSHI to ETH\n    function _get(address divide, uint256 decimals) internal view returns (uint256) {\n        uint256 price = uint256(1e36);\n        price = (price.mul(uint256(sushiOracle.latestAnswer())) / bar.totalSupply()).mul(sushi.balanceOf(address(bar)));\n\n        if (divide != address(0)) {\n            price = price / uint256(IAggregator(divide).latestAnswer());\n        }\n\n        return price / decimals;\n    }\n\n    function getDataParameter(address divide, uint256 decimals) public pure returns (bytes memory) {\n        return abi.encode(divide, decimals);\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) public override returns (bool, uint256) {\n        (address divide, uint256 decimals) = abi.decode(data, (address, uint256));\n        return (true, _get(divide, decimals));\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        (address divide, uint256 decimals) = abi.decode(data, (address, uint256));\n        return (true, _get(divide, decimals));\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"xSUSHI Chainlink\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"xSUSHI-LINK\";\n    }\n}\n"
    },
    "contracts/oracles/CompoundOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\ninterface IUniswapAnchoredView {\n    function price(string memory symbol) external view returns (uint256);\n}\n\ncontract CompoundOracle is IOracle {\n    using BoringMath for uint256;\n\n    IUniswapAnchoredView private constant ORACLE = IUniswapAnchoredView(0x922018674c12a7F0D394ebEEf9B58F186CdE13c1);\n\n    struct PriceInfo {\n        uint128 price;\n        uint128 blockNumber;\n    }\n\n    mapping(string => PriceInfo) public prices;\n\n    function _peekPrice(string memory symbol) internal view returns (uint256) {\n        if (bytes(symbol).length == 0) {\n            return 1000000;\n        } // To allow only using collateralSymbol or assetSymbol if paired against USDx\n        PriceInfo memory info = prices[symbol];\n        if (block.number > info.blockNumber + 8) {\n            return uint128(ORACLE.price(symbol)); // Prices are denominated with 6 decimals, so will fit in uint128\n        }\n        return info.price;\n    }\n\n    function _getPrice(string memory symbol) internal returns (uint256) {\n        if (bytes(symbol).length == 0) {\n            return 1000000;\n        } // To allow only using collateralSymbol or assetSymbol if paired against USDx\n        PriceInfo memory info = prices[symbol];\n        if (block.number > info.blockNumber + 8) {\n            info.price = uint128(ORACLE.price(symbol)); // Prices are denominated with 6 decimals, so will fit in uint128\n            info.blockNumber = uint128(block.number); // Blocknumber will fit in uint128\n            prices[symbol] = info;\n        }\n        return info.price;\n    }\n\n    function getDataParameter(\n        string memory collateralSymbol,\n        string memory assetSymbol,\n        uint256 division\n    ) public pure returns (bytes memory) {\n        return abi.encode(collateralSymbol, assetSymbol, division);\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) public override returns (bool, uint256) {\n        (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n        return (true, uint256(1e36).mul(_getPrice(assetSymbol)) / _getPrice(collateralSymbol) / division);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n        return (true, uint256(1e36).mul(_peekPrice(assetSymbol)) / _peekPrice(collateralSymbol) / division);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"Compound\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"COMP\";\n    }\n}\n"
    },
    "contracts/oracles/CompositeOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Using the same Copyleft License as in the original Repository\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\ncontract CompositeOracle is IOracle {\n    using BoringMath for uint256;\n\n    function getDataParameter(\n        IOracle oracle1,\n        IOracle oracle2,\n        bytes memory data1,\n        bytes memory data2\n    ) public pure returns (bytes memory) {\n        return abi.encode(oracle1, oracle2, data1, data2);\n    }\n\n    // Get the latest exchange rate, if no valid (recent) rate is available, return false\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) external override returns (bool, uint256) {\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        (bool success1, uint256 price1) = oracle1.get(data1);\n        (bool success2, uint256 price2) = oracle2.get(data2);\n        return (success1 && success2, price1.mul(price2) / 10**18);\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        (bool success1, uint256 price1) = oracle1.peek(data1);\n        (bool success2, uint256 price2) = oracle2.peek(data2);\n        return (success1 && success2, price1.mul(price2) / 10**18);\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        uint256 price1 = oracle1.peekSpot(data1);\n        uint256 price2 = oracle2.peekSpot(data2);\n        return price1.mul(price2) / 10**18;\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata data) public view override returns (string memory) {\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        return string(abi.encodePacked(oracle1.name(data1), \"+\", oracle2.name(data2)));\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata data) public view override returns (string memory) {\n        (IOracle oracle1, IOracle oracle2, bytes memory data1, bytes memory data2) = abi.decode(data, (IOracle, IOracle, bytes, bytes));\n        return string(abi.encodePacked(oracle1.symbol(data1), \"+\", oracle2.symbol(data2)));\n    }\n}\n"
    },
    "contracts/oracles/ChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ncontract ChainlinkOracle is IOracle {\n    using BoringMath for uint256; // Keep everything in uint256\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get(\n        address multiply,\n        address divide,\n        uint256 decimals\n    ) internal view returns (uint256) {\n        uint256 price = uint256(1e36);\n        if (multiply != address(0)) {\n            price = price.mul(uint256(IAggregator(multiply).latestAnswer()));\n        } else {\n            price = price.mul(1e18);\n        }\n\n        if (divide != address(0)) {\n            price = price / uint256(IAggregator(divide).latestAnswer());\n        }\n\n        return price / decimals;\n    }\n\n    function getDataParameter(\n        address multiply,\n        address divide,\n        uint256 decimals\n    ) public pure returns (bytes memory) {\n        return abi.encode(multiply, divide, decimals);\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata data) public override returns (bool, uint256) {\n        (address multiply, address divide, uint256 decimals) = abi.decode(data, (address, address, uint256));\n        return (true, _get(multiply, divide, decimals));\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata data) public view override returns (bool, uint256) {\n        (address multiply, address divide, uint256 decimals) = abi.decode(data, (address, address, uint256));\n        return (true, _get(multiply, divide, decimals));\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"Chainlink\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"LINK\";\n    }\n}\n"
    },
    "contracts/oracles/BandOracleFTM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// Band\n\ninterface IStdReference {\n    /// A structure returned whenever someone requests for standard reference data.\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n    }\n\n    /// Returns the price data for the given base/quote pair. Revert if not available.\n    function getReferenceData(string memory _base, string memory _quote)\n        external\n        view\n        returns (ReferenceData memory);\n\n    /// Similar to getReferenceData, but with multiple base/quote pairs at once.\n    function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes)\n        external\n        view\n        returns (ReferenceData[] memory);\n}\n\ncontract BandOracleFTMV1 is IOracle {\n    using BoringMath for uint256; // Keep everything in uint256\n\n    IStdReference constant ftmOracle = IStdReference(0x56E2898E0ceFF0D1222827759B56B28Ad812f92F);\n\n    // Calculates the lastest exchange rate\n    function _get() internal view returns (uint256 rate) {\n        IStdReference.ReferenceData memory referenceData = ftmOracle.getReferenceData(\"USD\", \"FTM\");\n        return referenceData.rate;\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"BAND FTM/USD\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"BAND\";\n    }\n}"
    },
    "contracts/oracles/AVAXOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ncontract AVAXOracle is IOracle {\n    using BoringMath for uint256; // Keep everything in uint256\n\n    IAggregator public constant avaxOracle = IAggregator(0x0A77230d17318075983913bC2145DB16C7366156);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e26 / uint256(avaxOracle.latestAnswer());\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata ) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"AVAX Chainlink\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"LINK/AVAX\";\n    }\n}\n"
    },
    "contracts/oracles/ALCXOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// Chainlink Aggregator\n\ninterface IAggregator {\n    function latestAnswer() external view returns (int256 answer);\n}\n\ncontract ALCXOracle is IOracle {\n    using BoringMath for uint256; // Keep everything in uint256\n\n    IAggregator public constant alcxOracle = IAggregator(0x194a9AaF2e0b67c35915cD01101585A33Fe25CAa);\n    IAggregator public constant ethUSDOracle = IAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n\n    // Calculates the lastest exchange rate\n    // Uses both divide and multiply only for tokens not supported directly by Chainlink, for example MKR/USD\n    function _get() internal view returns (uint256) {\n        return 1e44 / uint256(alcxOracle.latestAnswer()).mul(uint256(ethUSDOracle.latestAnswer()));\n    }\n\n    // Get the latest exchange rate\n    /// @inheritdoc IOracle\n    function get(bytes calldata) public override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the last exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peek(bytes calldata ) public view override returns (bool, uint256) {\n        return (true, _get());\n    }\n\n    // Check the current spot exchange rate without any state changes\n    /// @inheritdoc IOracle\n    function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n        (, rate) = peek(data);\n    }\n\n    /// @inheritdoc IOracle\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"ALCX Chainlink\";\n    }\n\n    /// @inheritdoc IOracle\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"LINK/ALCX\";\n    }\n}\n"
    },
    "contracts/mocks/OracleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../interfaces/IOracle.sol\";\n\n// WARNING: This oracle is only for testing, please use PeggedOracle for a fixed value oracle\ncontract OracleMock is IOracle {\n    using BoringMath for uint256;\n\n    uint256 public rate;\n    bool public success;\n\n    constructor() public {\n        success = true;\n    }\n\n    function set(uint256 rate_) public {\n        // The rate can be updated.\n        rate = rate_;\n    }\n\n    function setSuccess(bool val) public {\n        success = val;\n    }\n\n    function getDataParameter() public pure returns (bytes memory) {\n        return abi.encode(\"0x0\");\n    }\n\n    // Get the latest exchange rate\n    function get(bytes calldata) public override returns (bool, uint256) {\n        return (success, rate);\n    }\n\n    // Check the last exchange rate without any state changes\n    function peek(bytes calldata) public view override returns (bool, uint256) {\n        return (success, rate);\n    }\n\n    function peekSpot(bytes calldata) public view override returns (uint256) {\n        return rate;\n    }\n\n    function name(bytes calldata) public view override returns (string memory) {\n        return \"Test\";\n    }\n\n    function symbol(bytes calldata) public view override returns (string memory) {\n        return \"TEST\";\n    }\n}\n"
    },
    "contracts/interfaces/IKashiPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./IOracle.sol\";\nimport \"./ISwapper.sol\";\n\ninterface IKashiPair {\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event LogAccrue(uint256 accruedAmount, uint256 feeFraction, uint64 rate, uint256 utilization);\n    event LogAddAsset(address indexed from, address indexed to, uint256 share, uint256 fraction);\n    event LogAddCollateral(address indexed from, address indexed to, uint256 share);\n    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);\n    event LogExchangeRate(uint256 rate);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogRemoveAsset(address indexed from, address indexed to, uint256 share, uint256 fraction);\n    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);\n    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function accrue() external;\n\n    function accrueInfo()\n        external\n        view\n        returns (\n            uint64 interestPerBlock,\n            uint64 lastBlockAccrued,\n            uint128 feesEarnedFraction\n        );\n\n    function addAsset(\n        address to,\n        bool skim,\n        uint256 share\n    ) external returns (uint256 fraction);\n\n    function addCollateral(\n        address to,\n        bool skim,\n        uint256 share\n    ) external;\n\n    function allowance(address, address) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function asset() external view returns (IERC20);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);\n\n    function claimOwnership() external;\n\n    function collateral() external view returns (IERC20);\n\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2);\n\n    function decimals() external view returns (uint8);\n\n    function exchangeRate() external view returns (uint256);\n\n    function feeTo() external view returns (address);\n\n    function getInitData(\n        IERC20 collateral_,\n        IERC20 asset_,\n        IOracle oracle_,\n        bytes calldata oracleData_\n    ) external pure returns (bytes memory data);\n\n    function init(bytes calldata data) external payable;\n\n    function isSolvent(address user, bool open) external view returns (bool);\n\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata borrowParts,\n        address to,\n        ISwapper swapper,\n        bool open\n    ) external;\n\n    function masterContract() external view returns (address);\n\n    function name() external view returns (string memory);\n\n    function nonces(address) external view returns (uint256);\n\n    function oracle() external view returns (IOracle);\n\n    function oracleData() external view returns (bytes memory);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function removeAsset(address to, uint256 fraction) external returns (uint256 share);\n\n    function removeCollateral(address to, uint256 share) external;\n\n    function repay(\n        address to,\n        bool skim,\n        uint256 part\n    ) external returns (uint256 amount);\n\n    function setFeeTo(address newFeeTo) external;\n\n    function setSwapper(ISwapper swapper, bool enable) external;\n\n    function swappers(ISwapper) external view returns (bool);\n\n    function symbol() external view returns (string memory);\n\n    function totalAsset() external view returns (uint128 elastic, uint128 base);\n\n    function totalBorrow() external view returns (uint128 elastic, uint128 base);\n\n    function totalCollateralShare() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) external;\n\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\n\n    function userBorrowPart(address) external view returns (uint256);\n\n    function userCollateralShare(address) external view returns (uint256);\n\n    function withdrawFees() external;\n}\n"
    },
    "contracts/CauldronV2MultiChain.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Cauldron\r\n\r\n//    (                (   (\r\n//    )\\      )    (   )\\  )\\ )  (\r\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\r\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\r\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\r\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\r\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\r\n\r\n// Copyright (c) 2021 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @0xKeno - for all his invaluable contributions\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\r\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\r\nimport \"./MagicInternetMoney.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\n\r\n// solhint-disable avoid-low-level-calls\r\n// solhint-disable no-inline-assembly\r\n\r\n/// @title Cauldron\r\n/// @dev This contract allows contract calls to any contract (except BentoBox)\r\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\r\ncontract CauldronV2MultiChain is BoringOwnable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n    using RebaseLibrary for Rebase;\r\n    using BoringERC20 for IERC20;\r\n\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(uint128 accruedAmount);\r\n    event LogAddCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\r\n\r\n    // Immutables (for MasterContract and all clones)\r\n    IBentoBoxV1 public immutable bentoBox;\r\n    CauldronV2MultiChain public immutable masterContract;\r\n    IERC20 public immutable magicInternetMoney;\r\n\r\n    // MasterContract variables\r\n    address public feeTo;\r\n\r\n    // Per clone variables\r\n    // Clone init settings\r\n    IERC20 public collateral;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralShare; // Total collateral supplied\r\n    Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralShare;\r\n    mapping(address => uint256) public userBorrowPart;\r\n\r\n    /// @notice Exchange and interest rate tracking.\r\n    /// This is 'cached' here because calls to Oracles can be very expensive.\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 lastAccrued;\r\n        uint128 feesEarned;\r\n        uint64 INTEREST_PER_SECOND;\r\n    }\r\n\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // Settings\r\n    uint256 public COLLATERIZATION_RATE;\r\n    uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)\r\n\r\n    uint256 private constant EXCHANGE_RATE_PRECISION = 1e18;\r\n\r\n    uint256 public LIQUIDATION_MULTIPLIER; \r\n    uint256 private constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\r\n\r\n    uint256 public BORROW_OPENING_FEE;\r\n    uint256 private constant BORROW_OPENING_FEE_PRECISION = 1e5;\r\n\r\n    uint256 private constant DISTRIBUTION_PART = 10;\r\n    uint256 private constant DISTRIBUTION_PRECISION = 100;\r\n\r\n    /// @notice The constructor is only used for the initial master contract. Subsequent clones are initialised via `init`.\r\n    constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) public {\r\n        bentoBox = bentoBox_;\r\n        magicInternetMoney = magicInternetMoney_;\r\n        masterContract = this;\r\n    }\r\n\r\n    /// @notice Serves as the constructor for clones, as clones can't have a regular constructor\r\n    /// @dev `data` is abi encoded in the format: (IERC20 collateral, IERC20 asset, IOracle oracle, bytes oracleData)\r\n    function init(bytes calldata data) public payable override {\r\n        require(address(collateral) == address(0), \"Cauldron: already initialized\");\r\n        (collateral, oracle, oracleData, accrueInfo.INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi.decode(data, (IERC20, IOracle, bytes, uint64, uint256, uint256, uint256));\r\n        require(address(collateral) != address(0), \"Cauldron: bad pair\");\r\n    }\r\n\r\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\r\n    function accrue() public {\r\n        AccrueInfo memory _accrueInfo = accrueInfo;\r\n        // Number of seconds since accrue was called\r\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\r\n        if (elapsedTime == 0) {\r\n            return;\r\n        }\r\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        if (_totalBorrow.base == 0) {\r\n            accrueInfo = _accrueInfo;\r\n            return;\r\n        }\r\n\r\n        // Accrue interest\r\n        uint128 extraAmount = (uint256(_totalBorrow.elastic).mul(_accrueInfo.INTEREST_PER_SECOND).mul(elapsedTime) / 1e18).to128();\r\n        _totalBorrow.elastic = _totalBorrow.elastic.add(extraAmount);\r\n\r\n        _accrueInfo.feesEarned = _accrueInfo.feesEarned.add(extraAmount);\r\n        totalBorrow = _totalBorrow;\r\n        accrueInfo = _accrueInfo;\r\n\r\n        emit LogAccrue(extraAmount);\r\n    }\r\n\r\n    /// @notice Concrete implementation of `isSolvent`. Includes a third parameter to allow caching `exchangeRate`.\r\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\r\n    function _isSolvent(address user, uint256 _exchangeRate) internal view returns (bool) {\r\n        // accrue must have already been called!\r\n        uint256 borrowPart = userBorrowPart[user];\r\n        if (borrowPart == 0) return true;\r\n        uint256 collateralShare = userCollateralShare[user];\r\n        if (collateralShare == 0) return false;\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n\r\n        return\r\n            bentoBox.toAmount(\r\n                collateral,\r\n                collateralShare.mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION).mul(COLLATERIZATION_RATE),\r\n                false\r\n            ) >=\r\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\r\n            borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;\r\n    }\r\n\r\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\r\n    modifier solvent() {\r\n        _;\r\n        require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\r\n    }\r\n\r\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\r\n    /// This function is supposed to be invoked if needed because Oracle queries can be expensive.\r\n    /// @return updated True if `exchangeRate` was updated.\r\n    /// @return rate The new exchange rate.\r\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\r\n        (updated, rate) = oracle.get(oracleData);\r\n\r\n        if (updated) {\r\n            exchangeRate = rate;\r\n            emit LogExchangeRate(rate);\r\n        } else {\r\n            // Return the old rate if fetching wasn't successful\r\n            rate = exchangeRate;\r\n        }\r\n    }\r\n\r\n    /// @dev Helper function to move tokens.\r\n    /// @param token The ERC-20 token.\r\n    /// @param share The amount in shares to add.\r\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\r\n    /// Only used for accounting checks.\r\n    /// @param skim If True, only does a balance check on this contract.\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    function _addTokens(\r\n        IERC20 token,\r\n        uint256 share,\r\n        uint256 total,\r\n        bool skim\r\n    ) internal {\r\n        if (skim) {\r\n            require(share <= bentoBox.balanceOf(token, address(this)).sub(total), \"Cauldron: Skim too much\");\r\n        } else {\r\n            bentoBox.transfer(token, msg.sender, address(this), share);\r\n        }\r\n    }\r\n\r\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\r\n    /// @param to The receiver of the tokens.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.x\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    /// @param share The amount of shares to add for `to`.\r\n    function addCollateral(\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) public {\r\n        userCollateralShare[to] = userCollateralShare[to].add(share);\r\n        uint256 oldTotalCollateralShare = totalCollateralShare;\r\n        totalCollateralShare = oldTotalCollateralShare.add(share);\r\n        _addTokens(collateral, share, oldTotalCollateralShare, skim);\r\n        emit LogAddCollateral(skim ? address(bentoBox) : msg.sender, to, share);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `removeCollateral`.\r\n    function _removeCollateral(address to, uint256 share) internal {\r\n        userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);\r\n        totalCollateralShare = totalCollateralShare.sub(share);\r\n        emit LogRemoveCollateral(msg.sender, to, share);\r\n        bentoBox.transfer(collateral, address(this), to, share);\r\n    }\r\n\r\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\r\n    /// @param to The receiver of the shares.\r\n    /// @param share Amount of shares to remove.\r\n    function removeCollateral(address to, uint256 share) public solvent {\r\n        // accrue must be called because we check solvency\r\n        accrue();\r\n        _removeCollateral(to, share);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `borrow`.\r\n    function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\r\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\r\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));\r\n        userBorrowPart[msg.sender] = userBorrowPart[msg.sender].add(part);\r\n\r\n        // As long as there are tokens on this contract you can 'mint'... this enables limiting borrows\r\n        share = bentoBox.toShare(magicInternetMoney, amount, false);\r\n        bentoBox.transfer(magicInternetMoney, address(this), to, share);\r\n\r\n        emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);\r\n    }\r\n\r\n    /// @notice Sender borrows `amount` and transfers it to `to`.\r\n    /// @return part Total part of the debt held by borrowers.\r\n    /// @return share Total amount in shares borrowed.\r\n    function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {\r\n        accrue();\r\n        (part, share) = _borrow(to, amount);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `repay`.\r\n    function _repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) internal returns (uint256 amount) {\r\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\r\n        userBorrowPart[to] = userBorrowPart[to].sub(part);\r\n\r\n        uint256 share = bentoBox.toShare(magicInternetMoney, amount, true);\r\n        bentoBox.transfer(magicInternetMoney, skim ? address(bentoBox) : msg.sender, address(this), share);\r\n        emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);\r\n    }\r\n\r\n    /// @notice Repays a loan.\r\n    /// @param to Address of the user this payment should go.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    /// @param part The amount to repay. See `userBorrowPart`.\r\n    /// @return amount The total amount repayed.\r\n    function repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) public returns (uint256 amount) {\r\n        accrue();\r\n        amount = _repay(to, skim, part);\r\n    }\r\n\r\n    // Functions that need accrue to be called\r\n    uint8 internal constant ACTION_REPAY = 2;\r\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\r\n    uint8 internal constant ACTION_BORROW = 5;\r\n    uint8 internal constant ACTION_GET_REPAY_SHARE = 6;\r\n    uint8 internal constant ACTION_GET_REPAY_PART = 7;\r\n    uint8 internal constant ACTION_ACCRUE = 8;\r\n\r\n    // Functions that don't need accrue to be called\r\n    uint8 internal constant ACTION_ADD_COLLATERAL = 10;\r\n    uint8 internal constant ACTION_UPDATE_EXCHANGE_RATE = 11;\r\n\r\n    // Function on BentoBox\r\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\r\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\r\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\r\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\r\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\r\n\r\n    // Any external call (except to BentoBox)\r\n    uint8 internal constant ACTION_CALL = 30;\r\n\r\n    int256 internal constant USE_VALUE1 = -1;\r\n    int256 internal constant USE_VALUE2 = -2;\r\n\r\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\r\n    function _num(\r\n        int256 inNum,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal pure returns (uint256 outNum) {\r\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\r\n    }\r\n\r\n    /// @dev Helper function for depositing into `bentoBox`.\r\n    function _bentoDeposit(\r\n        bytes memory data,\r\n        uint256 value,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (uint256, uint256) {\r\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\r\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\r\n        share = int256(_num(share, value1, value2));\r\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\r\n    }\r\n\r\n    /// @dev Helper function to withdraw from the `bentoBox`.\r\n    function _bentoWithdraw(\r\n        bytes memory data,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (uint256, uint256) {\r\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\r\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\r\n    }\r\n\r\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\r\n    /// Calls to `bentoBox` are not allowed for obvious security reasons.\r\n    /// This also means that calls made from this contract shall *not* be trusted.\r\n    function _call(\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (bytes memory, uint8) {\r\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) =\r\n            abi.decode(data, (address, bytes, bool, bool, uint8));\r\n\r\n        if (useValue1 && !useValue2) {\r\n            callData = abi.encodePacked(callData, value1);\r\n        } else if (!useValue1 && useValue2) {\r\n            callData = abi.encodePacked(callData, value2);\r\n        } else if (useValue1 && useValue2) {\r\n            callData = abi.encodePacked(callData, value1, value2);\r\n        }\r\n\r\n        require(callee != address(bentoBox) && callee != address(this), \"Cauldron: can't call\");\r\n\r\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\r\n        require(success, \"Cauldron: call failed\");\r\n        return (returnData, returnValues);\r\n    }\r\n\r\n    struct CookStatus {\r\n        bool needsSolvencyCheck;\r\n        bool hasAccrued;\r\n    }\r\n\r\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\r\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\r\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\r\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\r\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\r\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\r\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\r\n    function cook(\r\n        uint8[] calldata actions,\r\n        uint256[] calldata values,\r\n        bytes[] calldata datas\r\n    ) external payable returns (uint256 value1, uint256 value2) {\r\n        CookStatus memory status;\r\n        for (uint256 i = 0; i < actions.length; i++) {\r\n            uint8 action = actions[i];\r\n            if (!status.hasAccrued && action < 10) {\r\n                accrue();\r\n                status.hasAccrued = true;\r\n            }\r\n            if (action == ACTION_ADD_COLLATERAL) {\r\n                (int256 share, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\r\n                addCollateral(to, skim, _num(share, value1, value2));\r\n            } else if (action == ACTION_REPAY) {\r\n                (int256 part, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\r\n                _repay(to, skim, _num(part, value1, value2));\r\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\r\n                (int256 share, address to) = abi.decode(datas[i], (int256, address));\r\n                _removeCollateral(to, _num(share, value1, value2));\r\n                status.needsSolvencyCheck = true;\r\n            } else if (action == ACTION_BORROW) {\r\n                (int256 amount, address to) = abi.decode(datas[i], (int256, address));\r\n                (value1, value2) = _borrow(to, _num(amount, value1, value2));\r\n                status.needsSolvencyCheck = true;\r\n            } else if (action == ACTION_UPDATE_EXCHANGE_RATE) {\r\n                (bool must_update, uint256 minRate, uint256 maxRate) = abi.decode(datas[i], (bool, uint256, uint256));\r\n                (bool updated, uint256 rate) = updateExchangeRate();\r\n                require((!must_update || updated) && rate > minRate && (maxRate == 0 || rate > maxRate), \"Cauldron: rate not ok\");\r\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\r\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) =\r\n                    abi.decode(datas[i], (address, address, bool, uint8, bytes32, bytes32));\r\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\r\n            } else if (action == ACTION_BENTO_DEPOSIT) {\r\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\r\n            } else if (action == ACTION_BENTO_WITHDRAW) {\r\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\r\n            } else if (action == ACTION_BENTO_TRANSFER) {\r\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\r\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\r\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\r\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\r\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\r\n            } else if (action == ACTION_CALL) {\r\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\r\n\r\n                if (returnValues == 1) {\r\n                    (value1) = abi.decode(returnData, (uint256));\r\n                } else if (returnValues == 2) {\r\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\r\n                }\r\n            } else if (action == ACTION_GET_REPAY_SHARE) {\r\n                int256 part = abi.decode(datas[i], (int256));\r\n                value1 = bentoBox.toShare(magicInternetMoney, totalBorrow.toElastic(_num(part, value1, value2), true), true);\r\n            } else if (action == ACTION_GET_REPAY_PART) {\r\n                int256 amount = abi.decode(datas[i], (int256));\r\n                value1 = totalBorrow.toBase(_num(amount, value1, value2), false);\r\n            }\r\n        }\r\n\r\n        if (status.needsSolvencyCheck) {\r\n            require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\r\n        }\r\n    }\r\n\r\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\r\n    /// @param users An array of user addresses.\r\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\r\n    /// @param to Address of the receiver in open liquidations if `swapper` is zero.\r\n    function liquidate(\r\n        address[] calldata users,\r\n        uint256[] calldata maxBorrowParts,\r\n        address to,\r\n        ISwapper swapper\r\n    ) public {\r\n        // Oracle can fail but we still need to allow liquidations\r\n        (, uint256 _exchangeRate) = updateExchangeRate();\r\n        accrue();\r\n\r\n        uint256 allCollateralShare;\r\n        uint256 allBorrowAmount;\r\n        uint256 allBorrowPart;\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!_isSolvent(user, _exchangeRate)) {\r\n                uint256 borrowPart;\r\n                {\r\n                    uint256 availableBorrowPart = userBorrowPart[user];\r\n                    borrowPart = maxBorrowParts[i] > availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];\r\n                    userBorrowPart[user] = availableBorrowPart.sub(borrowPart);\r\n                }\r\n                uint256 borrowAmount = _totalBorrow.toElastic(borrowPart, false);\r\n                uint256 collateralShare =\r\n                    bentoBoxTotals.toBase(\r\n                        borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /\r\n                            (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),\r\n                        false\r\n                    );\r\n\r\n                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);\r\n                emit LogRemoveCollateral(user, to, collateralShare);\r\n                emit LogRepay(msg.sender, user, borrowAmount, borrowPart);\r\n\r\n                // Keep totals\r\n                allCollateralShare = allCollateralShare.add(collateralShare);\r\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\r\n                allBorrowPart = allBorrowPart.add(borrowPart);\r\n            }\r\n        }\r\n        require(allBorrowAmount != 0, \"Cauldron: all are solvent\");\r\n        _totalBorrow.elastic = _totalBorrow.elastic.sub(allBorrowAmount.to128());\r\n        _totalBorrow.base = _totalBorrow.base.sub(allBorrowPart.to128());\r\n        totalBorrow = _totalBorrow;\r\n        totalCollateralShare = totalCollateralShare.sub(allCollateralShare);\r\n\r\n        // Apply a percentual fee share to sSpell holders\r\n        \r\n        {\r\n            uint256 distributionAmount = (allBorrowAmount.mul(LIQUIDATION_MULTIPLIER) / LIQUIDATION_MULTIPLIER_PRECISION).sub(allBorrowAmount).mul(DISTRIBUTION_PART) / DISTRIBUTION_PRECISION; // Distribution Amount\r\n            allBorrowAmount = allBorrowAmount.add(distributionAmount);\r\n            accrueInfo.feesEarned = accrueInfo.feesEarned.add(distributionAmount.to128());\r\n        }\r\n\r\n        uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);\r\n\r\n        // Swap using a swapper freely chosen by the caller\r\n        // Open (flash) liquidation: get proceeds first and provide the borrow after\r\n        bentoBox.transfer(collateral, address(this), to, allCollateralShare);\r\n        if (swapper != ISwapper(0)) {\r\n            swapper.swap(collateral, magicInternetMoney, msg.sender, allBorrowShare, allCollateralShare);\r\n        }\r\n\r\n        bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);\r\n    }\r\n\r\n    /// @notice Withdraws the fees accumulated.\r\n    function withdrawFees() public {\r\n        accrue();\r\n        address _feeTo = masterContract.feeTo();\r\n        uint256 _feesEarned = accrueInfo.feesEarned;\r\n        uint256 share = bentoBox.toShare(magicInternetMoney, _feesEarned, false);\r\n        bentoBox.transfer(magicInternetMoney, address(this), _feeTo, share);\r\n        accrueInfo.feesEarned = 0;\r\n\r\n        emit LogWithdrawFees(_feeTo, _feesEarned);\r\n    }\r\n\r\n    /// @notice Sets the beneficiary of interest accrued.\r\n    /// MasterContract Only Admin function.\r\n    /// @param newFeeTo The address of the receiver.\r\n    function setFeeTo(address newFeeTo) public onlyOwner {\r\n        feeTo = newFeeTo;\r\n        emit LogFeeTo(newFeeTo);\r\n    }\r\n\r\n    /// @notice reduces the supply of MIM\r\n    /// @param amount amount to reduce supply by\r\n    function reduceSupply(uint256 amount) public {\r\n        require(msg.sender == masterContract.owner(), \"Caller is not the owner\");\r\n        bentoBox.withdraw(magicInternetMoney, address(this), masterContract.owner(), amount, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/CauldronV2Checkpoint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Cauldron\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./MagicInternetMoney.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport \"./interfaces/ICheckpointToken.sol\";\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n/// @title Cauldron\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract CauldronV2Checkpoint is BoringOwnable, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogExchangeRate(uint256 rate);\n    event LogAccrue(uint128 accruedAmount);\n    event LogAddCollateral(address indexed from, address indexed to, uint256 share);\n    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);\n    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);\n    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    CauldronV2Checkpoint public immutable masterContract;\n    IERC20 public immutable magicInternetMoney;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC20 public collateral;\n    IOracle public oracle;\n    bytes public oracleData;\n\n    // Total amounts\n    uint256 public totalCollateralShare; // Total collateral supplied\n    Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n\n    // User balances\n    mapping(address => uint256) public userCollateralShare;\n    mapping(address => uint256) public userBorrowPart;\n\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    uint256 public exchangeRate;\n\n    struct AccrueInfo {\n        uint64 lastAccrued;\n        uint128 feesEarned;\n        uint64 INTEREST_PER_SECOND;\n    }\n\n    AccrueInfo public accrueInfo;\n\n    // Settings\n    uint256 public COLLATERIZATION_RATE;\n    uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)\n\n    uint256 private constant EXCHANGE_RATE_PRECISION = 1e18;\n\n    uint256 public LIQUIDATION_MULTIPLIER; \n    uint256 private constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\n\n    uint256 public BORROW_OPENING_FEE;\n    uint256 private constant BORROW_OPENING_FEE_PRECISION = 1e5;\n\n    uint256 private constant DISTRIBUTION_PART = 10;\n    uint256 private constant DISTRIBUTION_PRECISION = 100;\n\n    /// @notice The constructor is only used for the initial master contract. Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) public {\n        bentoBox = bentoBox_;\n        magicInternetMoney = magicInternetMoney_;\n        masterContract = this;\n    }\n\n    /// @notice Serves as the constructor for clones, as clones can't have a regular constructor\n    /// @dev `data` is abi encoded in the format: (IERC20 collateral, IERC20 asset, IOracle oracle, bytes oracleData)\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"Cauldron: already initialized\");\n        (collateral, oracle, oracleData, accrueInfo.INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi.decode(data, (IERC20, IOracle, bytes, uint64, uint256, uint256, uint256));\n        require(address(collateral) != address(0), \"Cauldron: bad pair\");\n    }\n\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\n    function accrue() public {\n        AccrueInfo memory _accrueInfo = accrueInfo;\n        // Number of seconds since accrue was called\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\n        if (elapsedTime == 0) {\n            return;\n        }\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\n\n        Rebase memory _totalBorrow = totalBorrow;\n        if (_totalBorrow.base == 0) {\n            accrueInfo = _accrueInfo;\n            return;\n        }\n\n        // Accrue interest\n        uint128 extraAmount = (uint256(_totalBorrow.elastic).mul(_accrueInfo.INTEREST_PER_SECOND).mul(elapsedTime) / 1e18).to128();\n        _totalBorrow.elastic = _totalBorrow.elastic.add(extraAmount);\n\n        _accrueInfo.feesEarned = _accrueInfo.feesEarned.add(extraAmount);\n        totalBorrow = _totalBorrow;\n        accrueInfo = _accrueInfo;\n\n        emit LogAccrue(extraAmount);\n    }\n\n    /// @notice Concrete implementation of `isSolvent`. Includes a third parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(address user, uint256 _exchangeRate) internal view returns (bool) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n        if (collateralShare == 0) return false;\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        return\n            bentoBox.toAmount(\n                collateral,\n                collateralShare.mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION).mul(COLLATERIZATION_RATE),\n                false\n            ) >=\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\n            borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;\n    }\n\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent() {\n        _;\n        require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(oracleData);\n\n        if (updated) {\n            exchangeRate = rate;\n            emit LogExchangeRate(rate);\n        } else {\n            // Return the old rate if fetching wasn't successful\n            rate = exchangeRate;\n        }\n    }\n\n    /// @dev Helper function to move tokens.\n    /// @param token The ERC-20 token.\n    /// @param share The amount in shares to add.\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\n    /// Only used for accounting checks.\n    /// @param skim If True, only does a balance check on this contract.\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\n    function _addTokens(\n        IERC20 token,\n        uint256 share,\n        uint256 total,\n        bool skim\n    ) internal {\n        if (skim) {\n            require(share <= bentoBox.balanceOf(token, address(this)).sub(total), \"Cauldron: Skim too much\");\n        } else {\n            bentoBox.transfer(token, msg.sender, address(this), share);\n        }\n    }\n\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\n    /// @param to The receiver of the tokens.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.x\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\n    /// @param share The amount of shares to add for `to`.\n    function addCollateral(\n        address to,\n        bool skim,\n        uint256 share\n    ) public {\n        //checkpoint before userCollateralShare is changed\n        ICheckpointToken(address(collateral)).user_checkpoint([to,address(0)]);\n\n        userCollateralShare[to] = userCollateralShare[to].add(share);\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        totalCollateralShare = oldTotalCollateralShare.add(share);\n        _addTokens(collateral, share, oldTotalCollateralShare, skim);\n        emit LogAddCollateral(skim ? address(bentoBox) : msg.sender, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address to, uint256 share) internal {\n        //checkpoint before userCollateralShare is changed\n        ICheckpointToken(address(collateral)).user_checkpoint([address(msg.sender),address(0)]);\n\n        userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);\n        totalCollateralShare = totalCollateralShare.sub(share);\n        emit LogRemoveCollateral(msg.sender, to, share);\n        bentoBox.transfer(collateral, address(this), to, share);\n    }\n\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\n    /// @param to The receiver of the shares.\n    /// @param share Amount of shares to remove.\n    function removeCollateral(address to, uint256 share) public solvent {\n        // accrue must be called because we check solvency\n        accrue();\n        _removeCollateral(to, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));\n        userBorrowPart[msg.sender] = userBorrowPart[msg.sender].add(part);\n\n        // As long as there are tokens on this contract you can 'mint'... this enables limiting borrows\n        share = bentoBox.toShare(magicInternetMoney, amount, false);\n        bentoBox.transfer(magicInternetMoney, address(this), to, share);\n\n        emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);\n    }\n\n    /// @notice Sender borrows `amount` and transfers it to `to`.\n    /// @return part Total part of the debt held by borrowers.\n    /// @return share Total amount in shares borrowed.\n    function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {\n        accrue();\n        (part, share) = _borrow(to, amount);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(\n        address to,\n        bool skim,\n        uint256 part\n    ) internal returns (uint256 amount) {\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\n        userBorrowPart[to] = userBorrowPart[to].sub(part);\n\n        uint256 share = bentoBox.toShare(magicInternetMoney, amount, true);\n        bentoBox.transfer(magicInternetMoney, skim ? address(bentoBox) : msg.sender, address(this), share);\n        emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);\n    }\n\n    /// @notice Repays a loan.\n    /// @param to Address of the user this payment should go.\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\n    /// @param part The amount to repay. See `userBorrowPart`.\n    /// @return amount The total amount repayed.\n    function repay(\n        address to,\n        bool skim,\n        uint256 part\n    ) public returns (uint256 amount) {\n        accrue();\n        amount = _repay(to, skim, part);\n    }\n\n    // Functions that need accrue to be called\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n    uint8 internal constant ACTION_BORROW = 5;\n    uint8 internal constant ACTION_GET_REPAY_SHARE = 6;\n    uint8 internal constant ACTION_GET_REPAY_PART = 7;\n    uint8 internal constant ACTION_ACCRUE = 8;\n\n    // Functions that don't need accrue to be called\n    uint8 internal constant ACTION_ADD_COLLATERAL = 10;\n    uint8 internal constant ACTION_UPDATE_EXCHANGE_RATE = 11;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` are not allowed for obvious security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) =\n            abi.decode(data, (address, bytes, bool, bool, uint8));\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(this), \"Cauldron: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"Cauldron: call failed\");\n        return (returnData, returnValues);\n    }\n\n    struct CookStatus {\n        bool needsSolvencyCheck;\n        bool hasAccrued;\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        CookStatus memory status;\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (!status.hasAccrued && action < 10) {\n                accrue();\n                status.hasAccrued = true;\n            }\n            if (action == ACTION_ADD_COLLATERAL) {\n                (int256 share, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\n                addCollateral(to, skim, _num(share, value1, value2));\n            } else if (action == ACTION_REPAY) {\n                (int256 part, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\n                _repay(to, skim, _num(part, value1, value2));\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (int256 share, address to) = abi.decode(datas[i], (int256, address));\n                _removeCollateral(to, _num(share, value1, value2));\n                status.needsSolvencyCheck = true;\n            } else if (action == ACTION_BORROW) {\n                (int256 amount, address to) = abi.decode(datas[i], (int256, address));\n                (value1, value2) = _borrow(to, _num(amount, value1, value2));\n                status.needsSolvencyCheck = true;\n            } else if (action == ACTION_UPDATE_EXCHANGE_RATE) {\n                (bool must_update, uint256 minRate, uint256 maxRate) = abi.decode(datas[i], (bool, uint256, uint256));\n                (bool updated, uint256 rate) = updateExchangeRate();\n                require((!must_update || updated) && rate > minRate && (maxRate == 0 || rate > maxRate), \"Cauldron: rate not ok\");\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(datas[i], (address, address, bool, uint8, bytes32, bytes32));\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_GET_REPAY_SHARE) {\n                int256 part = abi.decode(datas[i], (int256));\n                value1 = bentoBox.toShare(magicInternetMoney, totalBorrow.toElastic(_num(part, value1, value2), true), true);\n            } else if (action == ACTION_GET_REPAY_PART) {\n                int256 amount = abi.decode(datas[i], (int256));\n                value1 = totalBorrow.toBase(_num(amount, value1, value2), false);\n            }\n        }\n\n        if (status.needsSolvencyCheck) {\n            require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\n        }\n    }\n\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\n    /// @param users An array of user addresses.\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\n    /// @param to Address of the receiver in open liquidations if `swapper` is zero.\n    function liquidate(\n        address[] calldata users,\n        uint256[] calldata maxBorrowParts,\n        address to,\n        ISwapper swapper\n    ) public {\n        // Oracle can fail but we still need to allow liquidations\n        (, uint256 _exchangeRate) = updateExchangeRate();\n        accrue();\n\n        uint256 allCollateralShare;\n        uint256 allBorrowAmount;\n        uint256 allBorrowPart;\n        Rebase memory _totalBorrow = totalBorrow;\n        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);\n        for (uint256 i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (!_isSolvent(user, _exchangeRate)) {\n                uint256 borrowPart;\n                {\n                    uint256 availableBorrowPart = userBorrowPart[user];\n                    borrowPart = maxBorrowParts[i] > availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];\n                    userBorrowPart[user] = availableBorrowPart.sub(borrowPart);\n                }\n                uint256 borrowAmount = _totalBorrow.toElastic(borrowPart, false);\n                uint256 collateralShare =\n                    bentoBoxTotals.toBase(\n                        borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /\n                            (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),\n                        false\n                    );\n\n                //checkpoint before userCollateralShare is changed\n                ICheckpointToken(address(collateral)).user_checkpoint([user,address(0)]);\n                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);\n                emit LogRemoveCollateral(user, to, collateralShare);\n                emit LogRepay(msg.sender, user, borrowAmount, borrowPart);\n\n                // Keep totals\n                allCollateralShare = allCollateralShare.add(collateralShare);\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\n                allBorrowPart = allBorrowPart.add(borrowPart);\n            }\n        }\n        require(allBorrowAmount != 0, \"Cauldron: all are solvent\");\n        _totalBorrow.elastic = _totalBorrow.elastic.sub(allBorrowAmount.to128());\n        _totalBorrow.base = _totalBorrow.base.sub(allBorrowPart.to128());\n        totalBorrow = _totalBorrow;\n        totalCollateralShare = totalCollateralShare.sub(allCollateralShare);\n\n        // Apply a percentual fee share to sSpell holders\n        \n        {\n            uint256 distributionAmount = (allBorrowAmount.mul(LIQUIDATION_MULTIPLIER) / LIQUIDATION_MULTIPLIER_PRECISION).sub(allBorrowAmount).mul(DISTRIBUTION_PART) / DISTRIBUTION_PRECISION; // Distribution Amount\n            allBorrowAmount = allBorrowAmount.add(distributionAmount);\n            accrueInfo.feesEarned = accrueInfo.feesEarned.add(distributionAmount.to128());\n        }\n\n        uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);\n\n        // Swap using a swapper freely chosen by the caller\n        // Open (flash) liquidation: get proceeds first and provide the borrow after\n        bentoBox.transfer(collateral, address(this), to, allCollateralShare);\n        if (swapper != ISwapper(0)) {\n            swapper.swap(collateral, magicInternetMoney, msg.sender, allBorrowShare, allCollateralShare);\n        }\n\n        bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        accrue();\n        address _feeTo = masterContract.feeTo();\n        uint256 _feesEarned = accrueInfo.feesEarned;\n        uint256 share = bentoBox.toShare(magicInternetMoney, _feesEarned, false);\n        bentoBox.transfer(magicInternetMoney, address(this), _feeTo, share);\n        accrueInfo.feesEarned = 0;\n\n        emit LogWithdrawFees(_feeTo, _feesEarned);\n    }\n\n    /// @notice Sets the beneficiary of interest accrued.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n\n    /// @notice reduces the supply of MIM\n    /// @param amount amount to reduce supply by\n    function reduceSupply(uint256 amount) public {\n        require(msg.sender == masterContract.owner(), \"Caller is not the owner\");\n        bentoBox.withdraw(magicInternetMoney, address(this), address(this), amount, 0);\n        MagicInternetMoney(address(magicInternetMoney)).burn(amount);\n    }\n}\n"
    },
    "contracts/interfaces/ICheckpointToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface ICheckpointToken {\n    /// @notice checkpoint rewards for given accounts. needs to be called before any balance change\n    function user_checkpoint(address[2] calldata _accounts) external returns(bool);\n}\n"
    },
    "contracts/NFTPair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPair\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract NFTPair is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(address indexed borrower, uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPair public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // \"Shares\" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 => TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // `calculateIntest`.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns \"second-order\" interest-on-interest, which\n    // itself earns \"third-order\" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \\           x^k                \\              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why \"at least\"? There are also rounding errors. See\n    // `calculateInterest` for more detail.\n    // The factorial in the denominator \"wins\"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the \"true\" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in \"total\"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address => uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"NFTPair: already initialized\");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), \"NFTPair: bad pair\");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, \"NFTPair: not the lender\");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration >= cur.duration && params.valuation <= cur.valuation && params.annualInterestBPS <= cur.annualInterestBPS,\n                \"NFTPair: worse params\"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert(\"NFTPair: no collateral\");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS);\n    }\n\n    function _requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes `tokenId` as collateral and transfers it to `to`.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral as the lender. The loan has to be\n            // expired and not paid off:\n            require(msg.sender == loan.lender, \"NFTPair: not the lender\");\n            require(\n                // Addition is safe: both summands are smaller than 256 bits\n                uint256(loan.startTime) + tokenLoanParams[tokenId].duration <= block.timestamp,\n                \"NFTPair: not expired\"\n            );\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS,\n            \"NFTPair: bad params\"\n        );\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256(\"Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x06bcca6f35b7c1b98f11abbb10957d273a681069ba90358de25404f49e2430f8;\n\n    // keccak256(\"Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xf2c9128b0fb8406af3168320897e5ff08f3bb536dd5f804c29ed276e93ec4336;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        if (v == 0 && r == bytes32(0) && s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");\n        } else {\n            require(block.timestamp <= deadline, \"NFTPair: signature expired\");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    nonce,\n                    deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), v, r, s) == lender, \"NFTPair: signature invalid\");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(block.timestamp <= deadline, \"NFTPair: signature expired\");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                nonce,\n                deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, \"NFTPair: signature invalid\");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner's method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n > 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \\           principal * (t * aprBPS)^k        \\\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the \"theoretical\" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term_{k-1} * ------------                          (*)\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From (*) we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M >= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // <- Only overflow check we need\n        }\n\n        if (interest >= 2**128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, \"NFTPair: no loan\");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration > block.timestamp,\n            \"NFTPair: loan expired\"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), \"NFTPair: skim too much\");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), \"NFTPair: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"NFTPair: call failed\");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (\n                    uint256 tokenId,\n                    address borrower,\n                    TokenLoanParams memory params,\n                    bool skimFunds,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = abi.decode(datas[i], (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share > 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from OpenZeppelin contracts v3\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from OpenZeppelin contracts v3\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/CauldronV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Cauldron\r\n\r\n//    (                (   (\r\n//    )\\      )    (   )\\  )\\ )  (\r\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\r\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\r\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\r\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\r\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\r\n\r\n// Copyright (c) 2021 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @0xKeno - for all his invaluable contributions\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\r\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\r\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\r\nimport \"./MagicInternetMoney.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\n\r\n// solhint-disable avoid-low-level-calls\r\n// solhint-disable no-inline-assembly\r\n\r\n/// @title Cauldron\r\n/// @dev This contract allows contract calls to any contract (except BentoBox)\r\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\r\ncontract CauldronV2 is BoringOwnable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n    using RebaseLibrary for Rebase;\r\n    using BoringERC20 for IERC20;\r\n\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(uint128 accruedAmount);\r\n    event LogAddCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\r\n\r\n    // Immutables (for MasterContract and all clones)\r\n    IBentoBoxV1 public immutable bentoBox;\r\n    CauldronV2 public immutable masterContract;\r\n    IERC20 public immutable magicInternetMoney;\r\n\r\n    // MasterContract variables\r\n    address public feeTo;\r\n\r\n    // Per clone variables\r\n    // Clone init settings\r\n    IERC20 public collateral;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralShare; // Total collateral supplied\r\n    Rebase public totalBorrow; // elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralShare;\r\n    mapping(address => uint256) public userBorrowPart;\r\n\r\n    /// @notice Exchange and interest rate tracking.\r\n    /// This is 'cached' here because calls to Oracles can be very expensive.\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 lastAccrued;\r\n        uint128 feesEarned;\r\n        uint64 INTEREST_PER_SECOND;\r\n    }\r\n\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // Settings\r\n    uint256 public COLLATERIZATION_RATE;\r\n    uint256 private constant COLLATERIZATION_RATE_PRECISION = 1e5; // Must be less than EXCHANGE_RATE_PRECISION (due to optimization in math)\r\n\r\n    uint256 private constant EXCHANGE_RATE_PRECISION = 1e18;\r\n\r\n    uint256 public LIQUIDATION_MULTIPLIER; \r\n    uint256 private constant LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\r\n\r\n    uint256 public BORROW_OPENING_FEE;\r\n    uint256 private constant BORROW_OPENING_FEE_PRECISION = 1e5;\r\n\r\n    uint256 private constant DISTRIBUTION_PART = 10;\r\n    uint256 private constant DISTRIBUTION_PRECISION = 100;\r\n\r\n    /// @notice The constructor is only used for the initial master contract. Subsequent clones are initialised via `init`.\r\n    constructor(IBentoBoxV1 bentoBox_, IERC20 magicInternetMoney_) public {\r\n        bentoBox = bentoBox_;\r\n        magicInternetMoney = magicInternetMoney_;\r\n        masterContract = this;\r\n    }\r\n\r\n    /// @notice Serves as the constructor for clones, as clones can't have a regular constructor\r\n    /// @dev `data` is abi encoded in the format: (IERC20 collateral, IERC20 asset, IOracle oracle, bytes oracleData)\r\n    function init(bytes calldata data) public payable override {\r\n        require(address(collateral) == address(0), \"Cauldron: already initialized\");\r\n        (collateral, oracle, oracleData, accrueInfo.INTEREST_PER_SECOND, LIQUIDATION_MULTIPLIER, COLLATERIZATION_RATE, BORROW_OPENING_FEE) = abi.decode(data, (IERC20, IOracle, bytes, uint64, uint256, uint256, uint256));\r\n        require(address(collateral) != address(0), \"Cauldron: bad pair\");\r\n    }\r\n\r\n    /// @notice Accrues the interest on the borrowed tokens and handles the accumulation of fees.\r\n    function accrue() public {\r\n        AccrueInfo memory _accrueInfo = accrueInfo;\r\n        // Number of seconds since accrue was called\r\n        uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;\r\n        if (elapsedTime == 0) {\r\n            return;\r\n        }\r\n        _accrueInfo.lastAccrued = uint64(block.timestamp);\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        if (_totalBorrow.base == 0) {\r\n            accrueInfo = _accrueInfo;\r\n            return;\r\n        }\r\n\r\n        // Accrue interest\r\n        uint128 extraAmount = (uint256(_totalBorrow.elastic).mul(_accrueInfo.INTEREST_PER_SECOND).mul(elapsedTime) / 1e18).to128();\r\n        _totalBorrow.elastic = _totalBorrow.elastic.add(extraAmount);\r\n\r\n        _accrueInfo.feesEarned = _accrueInfo.feesEarned.add(extraAmount);\r\n        totalBorrow = _totalBorrow;\r\n        accrueInfo = _accrueInfo;\r\n\r\n        emit LogAccrue(extraAmount);\r\n    }\r\n\r\n    /// @notice Concrete implementation of `isSolvent`. Includes a third parameter to allow caching `exchangeRate`.\r\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\r\n    function _isSolvent(address user, uint256 _exchangeRate) internal view returns (bool) {\r\n        // accrue must have already been called!\r\n        uint256 borrowPart = userBorrowPart[user];\r\n        if (borrowPart == 0) return true;\r\n        uint256 collateralShare = userCollateralShare[user];\r\n        if (collateralShare == 0) return false;\r\n\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n\r\n        return\r\n            bentoBox.toAmount(\r\n                collateral,\r\n                collateralShare.mul(EXCHANGE_RATE_PRECISION / COLLATERIZATION_RATE_PRECISION).mul(COLLATERIZATION_RATE),\r\n                false\r\n            ) >=\r\n            // Moved exchangeRate here instead of dividing the other side to preserve more precision\r\n            borrowPart.mul(_totalBorrow.elastic).mul(_exchangeRate) / _totalBorrow.base;\r\n    }\r\n\r\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\r\n    modifier solvent() {\r\n        _;\r\n        require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\r\n    }\r\n\r\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\r\n    /// This function is supposed to be invoked if needed because Oracle queries can be expensive.\r\n    /// @return updated True if `exchangeRate` was updated.\r\n    /// @return rate The new exchange rate.\r\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\r\n        (updated, rate) = oracle.get(oracleData);\r\n\r\n        if (updated) {\r\n            exchangeRate = rate;\r\n            emit LogExchangeRate(rate);\r\n        } else {\r\n            // Return the old rate if fetching wasn't successful\r\n            rate = exchangeRate;\r\n        }\r\n    }\r\n\r\n    /// @dev Helper function to move tokens.\r\n    /// @param token The ERC-20 token.\r\n    /// @param share The amount in shares to add.\r\n    /// @param total Grand total amount to deduct from this contract's balance. Only applicable if `skim` is True.\r\n    /// Only used for accounting checks.\r\n    /// @param skim If True, only does a balance check on this contract.\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    function _addTokens(\r\n        IERC20 token,\r\n        uint256 share,\r\n        uint256 total,\r\n        bool skim\r\n    ) internal {\r\n        if (skim) {\r\n            require(share <= bentoBox.balanceOf(token, address(this)).sub(total), \"Cauldron: Skim too much\");\r\n        } else {\r\n            bentoBox.transfer(token, msg.sender, address(this), share);\r\n        }\r\n    }\r\n\r\n    /// @notice Adds `collateral` from msg.sender to the account `to`.\r\n    /// @param to The receiver of the tokens.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.x\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    /// @param share The amount of shares to add for `to`.\r\n    function addCollateral(\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) public {\r\n        userCollateralShare[to] = userCollateralShare[to].add(share);\r\n        uint256 oldTotalCollateralShare = totalCollateralShare;\r\n        totalCollateralShare = oldTotalCollateralShare.add(share);\r\n        _addTokens(collateral, share, oldTotalCollateralShare, skim);\r\n        emit LogAddCollateral(skim ? address(bentoBox) : msg.sender, to, share);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `removeCollateral`.\r\n    function _removeCollateral(address to, uint256 share) internal {\r\n        userCollateralShare[msg.sender] = userCollateralShare[msg.sender].sub(share);\r\n        totalCollateralShare = totalCollateralShare.sub(share);\r\n        emit LogRemoveCollateral(msg.sender, to, share);\r\n        bentoBox.transfer(collateral, address(this), to, share);\r\n    }\r\n\r\n    /// @notice Removes `share` amount of collateral and transfers it to `to`.\r\n    /// @param to The receiver of the shares.\r\n    /// @param share Amount of shares to remove.\r\n    function removeCollateral(address to, uint256 share) public solvent {\r\n        // accrue must be called because we check solvency\r\n        accrue();\r\n        _removeCollateral(to, share);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `borrow`.\r\n    function _borrow(address to, uint256 amount) internal returns (uint256 part, uint256 share) {\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / BORROW_OPENING_FEE_PRECISION; // A flat % fee is charged for any borrow\r\n        (totalBorrow, part) = totalBorrow.add(amount.add(feeAmount), true);\r\n        accrueInfo.feesEarned = accrueInfo.feesEarned.add(uint128(feeAmount));\r\n        userBorrowPart[msg.sender] = userBorrowPart[msg.sender].add(part);\r\n\r\n        // As long as there are tokens on this contract you can 'mint'... this enables limiting borrows\r\n        share = bentoBox.toShare(magicInternetMoney, amount, false);\r\n        bentoBox.transfer(magicInternetMoney, address(this), to, share);\r\n\r\n        emit LogBorrow(msg.sender, to, amount.add(feeAmount), part);\r\n    }\r\n\r\n    /// @notice Sender borrows `amount` and transfers it to `to`.\r\n    /// @return part Total part of the debt held by borrowers.\r\n    /// @return share Total amount in shares borrowed.\r\n    function borrow(address to, uint256 amount) public solvent returns (uint256 part, uint256 share) {\r\n        accrue();\r\n        (part, share) = _borrow(to, amount);\r\n    }\r\n\r\n    /// @dev Concrete implementation of `repay`.\r\n    function _repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) internal returns (uint256 amount) {\r\n        (totalBorrow, amount) = totalBorrow.sub(part, true);\r\n        userBorrowPart[to] = userBorrowPart[to].sub(part);\r\n\r\n        uint256 share = bentoBox.toShare(magicInternetMoney, amount, true);\r\n        bentoBox.transfer(magicInternetMoney, skim ? address(bentoBox) : msg.sender, address(this), share);\r\n        emit LogRepay(skim ? address(bentoBox) : msg.sender, to, amount, part);\r\n    }\r\n\r\n    /// @notice Repays a loan.\r\n    /// @param to Address of the user this payment should go.\r\n    /// @param skim True if the amount should be skimmed from the deposit balance of msg.sender.\r\n    /// False if tokens from msg.sender in `bentoBox` should be transferred.\r\n    /// @param part The amount to repay. See `userBorrowPart`.\r\n    /// @return amount The total amount repayed.\r\n    function repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) public returns (uint256 amount) {\r\n        accrue();\r\n        amount = _repay(to, skim, part);\r\n    }\r\n\r\n    // Functions that need accrue to be called\r\n    uint8 internal constant ACTION_REPAY = 2;\r\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\r\n    uint8 internal constant ACTION_BORROW = 5;\r\n    uint8 internal constant ACTION_GET_REPAY_SHARE = 6;\r\n    uint8 internal constant ACTION_GET_REPAY_PART = 7;\r\n    uint8 internal constant ACTION_ACCRUE = 8;\r\n\r\n    // Functions that don't need accrue to be called\r\n    uint8 internal constant ACTION_ADD_COLLATERAL = 10;\r\n    uint8 internal constant ACTION_UPDATE_EXCHANGE_RATE = 11;\r\n\r\n    // Function on BentoBox\r\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\r\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\r\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\r\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\r\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\r\n\r\n    // Any external call (except to BentoBox)\r\n    uint8 internal constant ACTION_CALL = 30;\r\n\r\n    int256 internal constant USE_VALUE1 = -1;\r\n    int256 internal constant USE_VALUE2 = -2;\r\n\r\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\r\n    function _num(\r\n        int256 inNum,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal pure returns (uint256 outNum) {\r\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\r\n    }\r\n\r\n    /// @dev Helper function for depositing into `bentoBox`.\r\n    function _bentoDeposit(\r\n        bytes memory data,\r\n        uint256 value,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (uint256, uint256) {\r\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\r\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\r\n        share = int256(_num(share, value1, value2));\r\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\r\n    }\r\n\r\n    /// @dev Helper function to withdraw from the `bentoBox`.\r\n    function _bentoWithdraw(\r\n        bytes memory data,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (uint256, uint256) {\r\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\r\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\r\n    }\r\n\r\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\r\n    /// Calls to `bentoBox` are not allowed for obvious security reasons.\r\n    /// This also means that calls made from this contract shall *not* be trusted.\r\n    function _call(\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 value1,\r\n        uint256 value2\r\n    ) internal returns (bytes memory, uint8) {\r\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) =\r\n            abi.decode(data, (address, bytes, bool, bool, uint8));\r\n\r\n        if (useValue1 && !useValue2) {\r\n            callData = abi.encodePacked(callData, value1);\r\n        } else if (!useValue1 && useValue2) {\r\n            callData = abi.encodePacked(callData, value2);\r\n        } else if (useValue1 && useValue2) {\r\n            callData = abi.encodePacked(callData, value1, value2);\r\n        }\r\n\r\n        require(callee != address(bentoBox) && callee != address(this), \"Cauldron: can't call\");\r\n\r\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\r\n        require(success, \"Cauldron: call failed\");\r\n        return (returnData, returnValues);\r\n    }\r\n\r\n    struct CookStatus {\r\n        bool needsSolvencyCheck;\r\n        bool hasAccrued;\r\n    }\r\n\r\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\r\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\r\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\r\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\r\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\r\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\r\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\r\n    function cook(\r\n        uint8[] calldata actions,\r\n        uint256[] calldata values,\r\n        bytes[] calldata datas\r\n    ) external payable returns (uint256 value1, uint256 value2) {\r\n        CookStatus memory status;\r\n        for (uint256 i = 0; i < actions.length; i++) {\r\n            uint8 action = actions[i];\r\n            if (!status.hasAccrued && action < 10) {\r\n                accrue();\r\n                status.hasAccrued = true;\r\n            }\r\n            if (action == ACTION_ADD_COLLATERAL) {\r\n                (int256 share, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\r\n                addCollateral(to, skim, _num(share, value1, value2));\r\n            } else if (action == ACTION_REPAY) {\r\n                (int256 part, address to, bool skim) = abi.decode(datas[i], (int256, address, bool));\r\n                _repay(to, skim, _num(part, value1, value2));\r\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\r\n                (int256 share, address to) = abi.decode(datas[i], (int256, address));\r\n                _removeCollateral(to, _num(share, value1, value2));\r\n                status.needsSolvencyCheck = true;\r\n            } else if (action == ACTION_BORROW) {\r\n                (int256 amount, address to) = abi.decode(datas[i], (int256, address));\r\n                (value1, value2) = _borrow(to, _num(amount, value1, value2));\r\n                status.needsSolvencyCheck = true;\r\n            } else if (action == ACTION_UPDATE_EXCHANGE_RATE) {\r\n                (bool must_update, uint256 minRate, uint256 maxRate) = abi.decode(datas[i], (bool, uint256, uint256));\r\n                (bool updated, uint256 rate) = updateExchangeRate();\r\n                require((!must_update || updated) && rate > minRate && (maxRate == 0 || rate > maxRate), \"Cauldron: rate not ok\");\r\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\r\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) =\r\n                    abi.decode(datas[i], (address, address, bool, uint8, bytes32, bytes32));\r\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\r\n            } else if (action == ACTION_BENTO_DEPOSIT) {\r\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\r\n            } else if (action == ACTION_BENTO_WITHDRAW) {\r\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\r\n            } else if (action == ACTION_BENTO_TRANSFER) {\r\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\r\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\r\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\r\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\r\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\r\n            } else if (action == ACTION_CALL) {\r\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\r\n\r\n                if (returnValues == 1) {\r\n                    (value1) = abi.decode(returnData, (uint256));\r\n                } else if (returnValues == 2) {\r\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\r\n                }\r\n            } else if (action == ACTION_GET_REPAY_SHARE) {\r\n                int256 part = abi.decode(datas[i], (int256));\r\n                value1 = bentoBox.toShare(magicInternetMoney, totalBorrow.toElastic(_num(part, value1, value2), true), true);\r\n            } else if (action == ACTION_GET_REPAY_PART) {\r\n                int256 amount = abi.decode(datas[i], (int256));\r\n                value1 = totalBorrow.toBase(_num(amount, value1, value2), false);\r\n            }\r\n        }\r\n\r\n        if (status.needsSolvencyCheck) {\r\n            require(_isSolvent(msg.sender, exchangeRate), \"Cauldron: user insolvent\");\r\n        }\r\n    }\r\n\r\n    /// @notice Handles the liquidation of users' balances, once the users' amount of collateral is too low.\r\n    /// @param users An array of user addresses.\r\n    /// @param maxBorrowParts A one-to-one mapping to `users`, contains maximum (partial) borrow amounts (to liquidate) of the respective user.\r\n    /// @param to Address of the receiver in open liquidations if `swapper` is zero.\r\n    function liquidate(\r\n        address[] calldata users,\r\n        uint256[] calldata maxBorrowParts,\r\n        address to,\r\n        ISwapper swapper\r\n    ) public {\r\n        // Oracle can fail but we still need to allow liquidations\r\n        (, uint256 _exchangeRate) = updateExchangeRate();\r\n        accrue();\r\n\r\n        uint256 allCollateralShare;\r\n        uint256 allBorrowAmount;\r\n        uint256 allBorrowPart;\r\n        Rebase memory _totalBorrow = totalBorrow;\r\n        Rebase memory bentoBoxTotals = bentoBox.totals(collateral);\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!_isSolvent(user, _exchangeRate)) {\r\n                uint256 borrowPart;\r\n                {\r\n                    uint256 availableBorrowPart = userBorrowPart[user];\r\n                    borrowPart = maxBorrowParts[i] > availableBorrowPart ? availableBorrowPart : maxBorrowParts[i];\r\n                    userBorrowPart[user] = availableBorrowPart.sub(borrowPart);\r\n                }\r\n                uint256 borrowAmount = _totalBorrow.toElastic(borrowPart, false);\r\n                uint256 collateralShare =\r\n                    bentoBoxTotals.toBase(\r\n                        borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(_exchangeRate) /\r\n                            (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),\r\n                        false\r\n                    );\r\n\r\n                userCollateralShare[user] = userCollateralShare[user].sub(collateralShare);\r\n                emit LogRemoveCollateral(user, to, collateralShare);\r\n                emit LogRepay(msg.sender, user, borrowAmount, borrowPart);\r\n\r\n                // Keep totals\r\n                allCollateralShare = allCollateralShare.add(collateralShare);\r\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\r\n                allBorrowPart = allBorrowPart.add(borrowPart);\r\n            }\r\n        }\r\n        require(allBorrowAmount != 0, \"Cauldron: all are solvent\");\r\n        _totalBorrow.elastic = _totalBorrow.elastic.sub(allBorrowAmount.to128());\r\n        _totalBorrow.base = _totalBorrow.base.sub(allBorrowPart.to128());\r\n        totalBorrow = _totalBorrow;\r\n        totalCollateralShare = totalCollateralShare.sub(allCollateralShare);\r\n\r\n        // Apply a percentual fee share to sSpell holders\r\n        \r\n        {\r\n            uint256 distributionAmount = (allBorrowAmount.mul(LIQUIDATION_MULTIPLIER) / LIQUIDATION_MULTIPLIER_PRECISION).sub(allBorrowAmount).mul(DISTRIBUTION_PART) / DISTRIBUTION_PRECISION; // Distribution Amount\r\n            allBorrowAmount = allBorrowAmount.add(distributionAmount);\r\n            accrueInfo.feesEarned = accrueInfo.feesEarned.add(distributionAmount.to128());\r\n        }\r\n\r\n        uint256 allBorrowShare = bentoBox.toShare(magicInternetMoney, allBorrowAmount, true);\r\n\r\n        // Swap using a swapper freely chosen by the caller\r\n        // Open (flash) liquidation: get proceeds first and provide the borrow after\r\n        bentoBox.transfer(collateral, address(this), to, allCollateralShare);\r\n        if (swapper != ISwapper(0)) {\r\n            swapper.swap(collateral, magicInternetMoney, msg.sender, allBorrowShare, allCollateralShare);\r\n        }\r\n\r\n        bentoBox.transfer(magicInternetMoney, msg.sender, address(this), allBorrowShare);\r\n    }\r\n\r\n    /// @notice Withdraws the fees accumulated.\r\n    function withdrawFees() public {\r\n        accrue();\r\n        address _feeTo = masterContract.feeTo();\r\n        uint256 _feesEarned = accrueInfo.feesEarned;\r\n        uint256 share = bentoBox.toShare(magicInternetMoney, _feesEarned, false);\r\n        bentoBox.transfer(magicInternetMoney, address(this), _feeTo, share);\r\n        accrueInfo.feesEarned = 0;\r\n\r\n        emit LogWithdrawFees(_feeTo, _feesEarned);\r\n    }\r\n\r\n    /// @notice Sets the beneficiary of interest accrued.\r\n    /// MasterContract Only Admin function.\r\n    /// @param newFeeTo The address of the receiver.\r\n    function setFeeTo(address newFeeTo) public onlyOwner {\r\n        feeTo = newFeeTo;\r\n        emit LogFeeTo(newFeeTo);\r\n    }\r\n\r\n    /// @notice reduces the supply of MIM\r\n    /// @param amount amount to reduce supply by\r\n    function reduceSupply(uint256 amount) public {\r\n        require(msg.sender == masterContract.owner(), \"Caller is not the owner\");\r\n        bentoBox.withdraw(magicInternetMoney, address(this), address(this), amount, 0);\r\n        MagicInternetMoney(address(magicInternetMoney)).burn(amount);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/LendingClubMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"../NFTPair.sol\";\n\n// Minimal implementation to set up some tests.\ncontract LendingClubMock {\n    INFTPair private immutable nftPair;\n    address private immutable investor;\n\n    constructor(INFTPair _nftPair, address _investor) public {\n        nftPair = _nftPair;\n        investor = _investor;\n    }\n\n    function init() public {\n        nftPair.bentoBox().setMasterContractApproval(address(this), address(nftPair.masterContract()), true, 0, bytes32(0), bytes32(0));\n    }\n\n    function willLend(uint256 tokenId, TokenLoanParams memory requested) external view returns (bool) {\n        if (msg.sender != address(nftPair)) {\n            return false;\n        }\n        TokenLoanParams memory accepted = _lendingConditions(tokenId);\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n\n        return\n            requested.valuation == accepted.valuation &&\n            requested.duration <= accepted.duration &&\n            requested.annualInterestBPS >= accepted.annualInterestBPS;\n    }\n\n    function _lendingConditions(uint256 tokenId) private pure returns (TokenLoanParams memory) {\n        TokenLoanParams memory conditions;\n        // No specific conditions given, but we'll take all even-numbered\n        // ones at 100% APY:\n        if (tokenId % 2 == 0) {\n            // 256-bit addition fits by the above check.\n            // Cast is.. relatively safe: this is a mock implementation,\n            // production use is unlikely to follow this pattern for valuing\n            // loans, and manipulating the token ID can only break the logic by\n            // making the loan \"safer\" for the lender.\n            conditions.valuation = uint128((tokenId + 1) * 10**18);\n            conditions.duration = 365 days;\n            conditions.annualInterestBPS = 10_000;\n        }\n        return conditions;\n    }\n\n    function lendingConditions(address _nftPair, uint256 tokenId) external view returns (TokenLoanParams memory) {\n        if (_nftPair != address(nftPair)) {\n            TokenLoanParams memory empty;\n            return empty;\n        } else {\n            return _lendingConditions(tokenId);\n        }\n    }\n\n    function seizeCollateral(uint256 tokenId) external {\n        nftPair.removeCollateral(tokenId, investor);\n    }\n\n    function withdrawFunds(uint256 bentoShares) external {\n        nftPair.bentoBox().transfer(nftPair.asset(), address(this), investor, bentoShares);\n    }\n}\n"
    },
    "contracts/mocks/SimpleStrategyMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@sushiswap/bentobox-sdk/contracts/IStrategy.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\n// solhint-disable not-rely-on-time\n\ncontract SimpleStrategyMock is IStrategy {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    IERC20 private immutable token;\n    address private immutable bentoBox;\n\n    modifier onlyBentoBox() {\n        require(msg.sender == bentoBox, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    constructor(address bentoBox_, IERC20 token_) public {\n        bentoBox = bentoBox_;\n        token = token_;\n    }\n\n    // Send the assets to the Strategy and call skim to invest them\n    function skim(uint256) external override onlyBentoBox {\n        // Leave the tokens on the contract\n        return;\n    }\n\n    // Harvest any profits made converted to the asset and pass them to the caller\n    function harvest(uint256 balance, address) external override onlyBentoBox returns (int256 amountAdded) {\n        amountAdded = int256(token.balanceOf(address(this)).sub(balance));\n        token.safeTransfer(bentoBox, uint256(amountAdded)); // Add as profit\n    }\n\n    // Withdraw assets. The returned amount can differ from the requested amount due to rounding or if the request was more than there is.\n    function withdraw(uint256 amount) external override onlyBentoBox returns (uint256 actualAmount) {\n        token.safeTransfer(bentoBox, uint256(amount)); // Add as profit\n        actualAmount = amount;\n    }\n\n    // Withdraw all assets in the safest way possible. This shouldn't fail.\n    function exit(uint256 balance) external override onlyBentoBox returns (int256 amountAdded) {\n        amountAdded = 0;\n        token.safeTransfer(bentoBox, balance);\n    }\n}\n"
    },
    "contracts/helpers/YearnLiquidityMigrationHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface IYearnVault {\n    function deposit(uint256 amount, address recipient) external returns (uint256 shares);\n}\n\ncontract YearnLiquidityMigrationHelper {\n    using BoringMath for uint256;\n    using BoringERC20 for IERC20;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n    }\n\n    function migrate(\n        IERC20 token,\n        IYearnVault vault,\n        uint256 amount,\n        address recipient\n    ) external {\n        token.approve(address(vault), amount);\n        uint256 shares = vault.deposit(amount, address(bentoBox));\n        bentoBox.deposit(token, address(bentoBox), recipient, shares, 0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/YVIBSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount, bool use_underlying) external returns(uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n    function balanceOf(address user) external view returns (uint256);\n}\n\ncontract YVIBSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    \n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool constant public IronBank = CurvePool(0x2dded6Da1BF5DBdF597C45fcFaa3194e53EcfeAF);\n    YearnVault constant public YVIB = YearnVault(0x27b7b1ad7288079A66d12350c828D3C00A6F07d7);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        uint256 amountFrom = YVIB.withdraw();\n\n        IronBank.remove_liquidity_one_coin(amountFrom, 2, 0, true);\n\n        uint256 amountIntermediate = TETHER.balanceOf(address(this));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/YVCrvStETHSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external returns(uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n    function balanceOf(address user) external view returns (uint256);\n}\n\ninterface IWETH is IERC20 {\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function deposit() external payable;\n}\n\ncontract YVCrvStETHSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    IWETH public constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool constant public STETH = CurvePool(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);\n    YearnVault constant public YVSTETH = YearnVault(0xdCD90C7f6324cfa40d7169ef80b12031770B4325);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    receive() external payable {}\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        {\n\n        uint256 amountFrom = YVSTETH.withdraw();\n\n        STETH.remove_liquidity_one_coin(amountFrom, 0, 0);\n\n        }\n\n        uint256 amountSecond = address(this).balance;\n\n        WETH.deposit{value: amountSecond}();\n        WETH.transfer(address(pair), amountSecond);\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        uint256 amountIntermediate = getAmountOut(amountSecond, reserve0, reserve1);\n        pair.swap(0, amountIntermediate, address(this), new bytes(0));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/XSushiSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface SushiBar {\n    function leave(uint256 share) external;\n}\n\ninterface Sushi is IERC20 {\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract YVXSushiSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);    \n    SushiBar public constant xSushi = SushiBar(0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272);\n    Sushi public constant SUSHI = Sushi(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n    IUniswapV2Pair constant SUSHI_WETH = IUniswapV2Pair(0x795065dCc9f64b5614C407a6EFDC400DA6221FB0);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        {\n\n        (uint256 amountXSushiFrom, ) = bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        xSushi.leave(amountXSushiFrom);\n\n        }\n        uint256 amountFirst;\n\n        {\n\n        uint256 amountFrom = SUSHI.balanceOf(address(this));\n\n        SUSHI.transfer(address(SUSHI_WETH), amountFrom);\n\n        (uint256 reserve0, uint256 reserve1, ) = SUSHI_WETH.getReserves();\n        \n        amountFirst = getAmountOut(amountFrom, reserve0, reserve1);\n        \n        }\n\n        SUSHI_WETH.swap(0, amountFirst, address(pair), new bytes(0));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        uint256 amountIntermediate = getAmountOut(amountFirst, reserve0, reserve1);\n        pair.swap(0, amountIntermediate, address(this), new bytes(0));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/wOHMSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface IWOHM {\n    function wrap( uint _amount ) external returns ( uint );\n    function unwrap( uint _amount ) external returns ( uint );\n}\n\ninterface IOHM is IERC20 {\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\ninterface IStakingManager {\n    function unstake( uint _amount, bool _trigger ) external;\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n}\n\ncontract wOHMSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IERC20 public constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);    \n    IUniswapV2Pair constant OHM_DAI = IUniswapV2Pair(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant SOHM = IERC20(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F);\n    IWOHM public constant WOHM = IWOHM(0xCa76543Cf381ebBB277bE79574059e32108e3E65);\n    IStakingManager public constant STAKING_MANAGER = IStakingManager(0xFd31c7d00Ca47653c6Ce64Af53c1571f9C36566a);\n    IOHM public constant OHM = IOHM(0x383518188C0C6d7730D91b2c03a03C837814a899);\n\n    constructor(\n    ) public {\n        DAI.approve(address(MIM3POOL), type(uint256).max);\n        SOHM.approve(address(STAKING_MANAGER), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        \n        uint256 amountFirst;\n\n        {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        amountFirst = WOHM.unwrap(amountFrom);\n\n        }\n\n        STAKING_MANAGER.unstake(amountFirst, false);\n\n        OHM.transfer(address(OHM_DAI), amountFirst);\n\n        (uint256 reserve0, uint256 reserve1, ) = OHM_DAI.getReserves();\n        \n        uint256 amountDAI = getAmountOut(amountFirst, reserve0, reserve1);\n\n        OHM_DAI.swap(0, amountDAI, address(this), new bytes(0));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(1, 0, amountDAI, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/wMEMOSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"../../libraries/UniswapV2Library.sol\";\n\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface IWMEMO is IERC20 {\n    function wrap( uint _amount ) external returns ( uint );\n    function unwrap( uint _amount ) external returns ( uint );\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\ninterface ITIME is IERC20 {\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\ninterface IStakingManager {\n    function unstake( uint _amount, bool _trigger ) external;\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n}\n\ncontract wMEMOSwapper is ISwapper {\n    using BoringMath for uint256;\n\n   // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xf4F46382C2bE1603Dc817551Ff9A7b333Ed1D18f);\n    IUniswapV2Pair constant WMEMO_MIM = IUniswapV2Pair(0x4d308C46EA9f234ea515cC51F16fba776451cac8);\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant MEMO = IERC20(0x136Acd46C134E8269052c62A67042D6bDeDde3C9);\n    IWMEMO public constant WMEMO = IWMEMO(0x0da67235dD5787D67955420C84ca1cEcd4E5Bb3b);\n    IStakingManager public constant STAKING_MANAGER = IStakingManager(0x4456B87Af11e87E329AB7d7C7A246ed1aC2168B9);\n    ITIME public constant TIME = ITIME(0xb54f16fB19478766A268F172C9480f8da1a7c9C3);\n    address private constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n    constructor(\n    ) public {\n        MEMO.approve(address(STAKING_MANAGER), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        \n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n\n        (address token0, ) = UniswapV2Library.sortTokens(address(WMEMO), address(WMEMO_MIM));\n\n        (uint256 reserve0, uint256 reserve1, ) = WMEMO_MIM.getReserves();\n\n        (reserve0, reserve1) = address(WMEMO) == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint256 amountTo = getAmountOut(amountFrom, reserve0, reserve1);\n\n        (uint256 amount0Out, uint256 amount1Out) = address(WMEMO) == token0\n                ? (uint256(0), amountTo)\n                : (amountTo, uint256(0));\n\n        WMEMO_MIM.swap(amount0Out, amount1Out, address(bentoBox), new bytes(0));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/swappers/Liquidations/ArbEthSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"../../libraries/UniswapV2Library.sol\";\n\n\ncontract ArbEthSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0x74c764D41B77DBbb4fe771daB1939B00b146894A);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0xb6DD51D5425861C808Fd60827Ab6CFBfFE604959);\n    IERC20 constant WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n    IERC20 public constant MIM = IERC20(0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A);\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom,) = bentoBox.withdraw(fromToken, address(this), address(pair), 0, shareFrom);\n\n        (address token0, ) = UniswapV2Library.sortTokens(address(MIM), address(WETH));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (reserve0, reserve1) = address(WETH) == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint256  amountTo = getAmountOut(amountFrom, reserve0, reserve1);\n\n        (uint256 amount0Out, uint256 amount1Out) = address(WETH) == token0\n                ? (uint256(0), amountTo)\n                : (amountTo, uint256(0));\n\n        pair.swap(amount0Out, amount1Out, address(bentoBox), new bytes(0));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/wMemoLevSwapper.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"../../libraries/UniswapV2Library.sol\";\n\ninterface IWMEMO is IERC20 {\n    function wrap( uint _amount ) external returns ( uint );\n    function unwrap( uint _amount ) external returns ( uint );\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\ninterface IStakingManager {\n    function unstake( uint _amount, bool _trigger ) external;\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n    function claim ( address _recipient ) external;\n}\n\ncontract wMEMOLevSwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xf4F46382C2bE1603Dc817551Ff9A7b333Ed1D18f);\n    IUniswapV2Pair constant WMEMO_MIM = IUniswapV2Pair(0x4d308C46EA9f234ea515cC51F16fba776451cac8);\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant MEMO = IERC20(0x136Acd46C134E8269052c62A67042D6bDeDde3C9);\n    IWMEMO public constant WMEMO = IWMEMO(0x0da67235dD5787D67955420C84ca1cEcd4E5Bb3b);\n    IStakingManager public constant STAKING_MANAGER = IStakingManager(0x4456B87Af11e87E329AB7d7C7A246ed1aC2168B9);\n    IERC20 public constant TIME = IERC20(0xb54f16fB19478766A268F172C9480f8da1a7c9C3);\n    address private constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    constructor(\n    ) public {\n        TIME.approve(address(STAKING_MANAGER), type(uint256).max);\n        MEMO.approve(address(WMEMO), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountMIMFrom, ) = bentoBox.withdraw(MIM, address(this), address(WMEMO_MIM), 0, shareFrom);\n\n        (address token0, ) = UniswapV2Library.sortTokens(address(WMEMO), address(MIM));\n\n        (uint256 reserve0, uint256 reserve1, ) = WMEMO_MIM.getReserves();\n\n        (reserve0, reserve1) = address(MIM) == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint256 amountTo = getAmountOut(amountMIMFrom, reserve0, reserve1);\n\n        (uint256 amount0Out, uint256 amount1Out) = address(MIM) == token0\n                ? (uint256(0), amountTo)\n                : (amountTo, uint256(0));\n\n        WMEMO_MIM.swap(amount0Out, amount1Out, address(bentoBox), new bytes(0));\n\n        (, shareReturned) = bentoBox.deposit(WMEMO, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n}"
    },
    "contracts/swappers/Leverage/ArbEthLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"../../libraries/UniswapV2Library.sol\";\n\ncontract ArbEthLevSwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0x74c764D41B77DBbb4fe771daB1939B00b146894A);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0xb6DD51D5425861C808Fd60827Ab6CFBfFE604959);\n    IERC20 constant WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n    IERC20 public constant MIM = IERC20(0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A);\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(pair), 0, shareFrom);\n\n        (address token0, ) = UniswapV2Library.sortTokens(address(MIM), address(WETH));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (reserve0, reserve1) = address(MIM) == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint256  amountTo = getAmountOut(amountFrom, reserve0, reserve1);\n\n        (uint256 amount0Out, uint256 amount1Out) = address(MIM) == token0\n                ? (uint256(0), amountTo)\n                : (amountTo, uint256(0));\n\n        pair.swap(amount0Out, amount1Out, address(bentoBox), new bytes(0));\n\n        (, shareReturned) = bentoBox.deposit(WETH, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/UniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.6.12;\n\nimport './libraries/SafeMath.sol';\n\ncontract UniswapV2ERC20 {\n    using SafeMathUniswap for uint;\n\n    string public constant name = 'SushiSwap LP Token';\n    string public constant symbol = 'SLP';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/UniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.6.12;\n\nimport './UniswapV2ERC20.sol';\nimport './libraries/Math.sol';\nimport './libraries/UQ112x112.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IUniswapV2Factory.sol';\nimport './interfaces/IUniswapV2Callee.sol';\n\ninterface IMigrator {\n    // Return the desired amount of liquidity token that the migrator wants.\n    function desiredLiquidity() external view returns (uint256);\n}\n\ncontract UniswapV2Pair is UniswapV2ERC20 {\n    using SafeMathUniswap  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20Uniswap(token0).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            address migrator = IUniswapV2Factory(factory).migrator();\n            if (msg.sender == migrator) {\n                liquidity = IMigrator(migrator).desiredLiquidity();\n                require(liquidity > 0 && liquidity != uint256(-1), \"Bad desired liquidity\");\n            } else {\n                require(migrator == address(0), \"Must not have migrator\");\n                liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n            }\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        uint balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20Uniswap(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20Uniswap(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20Uniswap(token0).balanceOf(address(this)), IERC20Uniswap(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.6.12;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.6.12;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IERC20Uniswap {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "contracts/mocks/SushiSwapPairMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@sushiswap/core/contracts/uniswapv2/UniswapV2Pair.sol\";\n\ncontract SushiSwapPairMock is UniswapV2Pair {\n    constructor() public UniswapV2Pair() {\n        return;\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/UniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.6.12;\n\nimport './interfaces/IUniswapV2Factory.sol';\nimport './UniswapV2Pair.sol';\n\ncontract UniswapV2Factory is IUniswapV2Factory {\n    address public override feeTo;\n    address public override feeToSetter;\n    address public override migrator;\n\n    mapping(address => mapping(address => address)) public override getPair;\n    address[] public override allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    constructor(address _feeToSetter) public {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external override view returns (uint) {\n        return allPairs.length;\n    }\n\n    function pairCodeHash() external pure returns (bytes32) {\n        return keccak256(type(UniswapV2Pair).creationCode);\n    }\n\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        UniswapV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external override {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeTo = _feeTo;\n    }\n\n    function setMigrator(address _migrator) external override {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        migrator = _migrator;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external override {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeToSetter = _feeToSetter;\n    }\n\n}\n"
    },
    "contracts/mocks/SushiSwapFactoryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/UniswapV2Factory.sol\";\n\ncontract SushiSwapFactoryMock is UniswapV2Factory {\n    constructor() public UniswapV2Factory(msg.sender) {\n        return;\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/WethSwapper.sol": {
      "content": "pragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external;\n}\n\ninterface IThreeCrypto is CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n    function balanceOf(address user) external view returns (uint256);\n}\n\ninterface IConvex is IERC20{\n    function withdrawAndUnwrap(uint256 _amount) external;\n}\n\ncontract WethSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IThreeCrypto constant public threecrypto = IThreeCrypto(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n        WETH.approve(address(threecrypto), type(uint256).max);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = degenBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        threecrypto.exchange(2, 0, amountFrom, 0);\n\n        uint256 amountIntermediate = TETHER.balanceOf(address(this));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(degenBox));\n\n        (, shareReturned) = degenBox.deposit(toToken, address(degenBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/swappers/Liquidations/WbtcSwapper.sol": {
      "content": "pragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external;\n}\n\ninterface IThreeCrypto is CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n    function balanceOf(address user) external view returns (uint256);\n}\n\ninterface IConvex is IERC20{\n    function withdrawAndUnwrap(uint256 _amount) external;\n}\n\ncontract WbtcSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IThreeCrypto constant public threecrypto = IThreeCrypto(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n        WBTC.approve(address(threecrypto), type(uint256).max);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = degenBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        threecrypto.exchange(1, 0, amountFrom, 0);\n\n        uint256 amountIntermediate = TETHER.balanceOf(address(this));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(degenBox));\n\n        (, shareReturned) = degenBox.deposit(toToken, address(degenBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/swappers/Liquidations/ThreeCryptoSwapper.sol": {
      "content": "pragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function remove_liquidity_one_coin(uint256 tokenAmount, uint256 i, uint256 min_amount) external;\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n    function balanceOf(address user) external view returns (uint256);\n}\n\ninterface IConvex is IERC20{\n    function withdrawAndUnwrap(uint256 _amount) external;\n}\n\ncontract ThreeCryptoSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    \n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool constant public threecrypto = CurvePool(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    IConvex public constant cvx3Crypto = IConvex(0x5958A8DB7dfE0CC49382209069b00F54e17929C2);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        cvx3Crypto.withdrawAndUnwrap(amountFrom);\n\n        threecrypto.remove_liquidity_one_coin(amountFrom, 0, 0);\n\n        uint256 amountIntermediate = TETHER.balanceOf(address(this));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/swappers/Liquidations/sSpellSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface IsSpell {\n    function burn(address to, uint256 shares) external returns (bool);\n}\n\ninterface ISpell is IERC20 {\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract SSpellSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);    \n    IsSpell public constant sSpell = IsSpell(0x26FA3fFFB6EfE8c1E69103aCb4044C26B9A106a9);\n    ISpell public constant SPELL = ISpell(0x090185f2135308BaD17527004364eBcC2D37e5F6);\n    IUniswapV2Pair constant SPELL_ETH = IUniswapV2Pair(0xb5De0C3753b6E1B4dBA616Db82767F17513E6d4E);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n\n    constructor(\n    ) public {\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        {\n\n        (uint256 amountSSpellFrom, ) = bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        sSpell.burn(address(this), amountSSpellFrom);\n\n        }\n        uint256 amountFirst;\n\n        {\n\n        uint256 amountFrom = SPELL.balanceOf(address(this));\n\n        SPELL.transfer(address(SPELL_ETH), amountFrom);\n\n        (uint256 reserve0, uint256 reserve1, ) = SPELL_ETH.getReserves();\n        \n        amountFirst = getAmountOut(amountFrom, reserve0, reserve1);\n        \n        }\n\n        SPELL_ETH.swap(0, amountFirst, address(pair), new bytes(0));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        uint256 amountIntermediate = getAmountOut(amountFirst, reserve0, reserve1);\n        pair.swap(0, amountIntermediate, address(this), new bytes(0));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/swappers/Liquidations/SpellSuperSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface IsSpell {\n    function burn(address to, uint256 shares) external returns (bool);\n}\n\ninterface ISpell is IERC20 {\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract SpellSuperSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);    \n    IsSpell public constant sSpell = IsSpell(0x26FA3fFFB6EfE8c1E69103aCb4044C26B9A106a9);\n    ISpell public constant SPELL = ISpell(0x090185f2135308BaD17527004364eBcC2D37e5F6);\n    IUniswapV2Pair constant SPELL_ETH = IUniswapV2Pair(0xb5De0C3753b6E1B4dBA616Db82767F17513E6d4E);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n\n    constructor(\n    ) public {\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(SPELL_ETH), 0, shareFrom);\n\n        uint256 amountFirst;\n\n        {\n\n        (uint256 reserve0, uint256 reserve1, ) = SPELL_ETH.getReserves();\n        \n        amountFirst = getAmountOut(amountFrom, reserve0, reserve1);\n        \n        }\n\n        SPELL_ETH.swap(0, amountFirst, address(pair), new bytes(0));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        uint256 amountIntermediate = getAmountOut(amountFirst, reserve0, reserve1);\n        pair.swap(0, amountIntermediate, address(this), new bytes(0));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/swappers/Liquidations/RenCrvSwapper.sol": {
      "content": "pragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function remove_liquidity_one_coin(uint256 tokenAmount, int128 i, uint256 min_amount) external;\n}\n\ninterface IThreeCrypto is CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n    function balanceOf(address user) external view returns (uint256);\n}\n\ninterface IConvex is IERC20{\n    function withdrawAndUnwrap(uint256 _amount) external;\n}\n\ncontract RenCrvSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool constant public renCrv = CurvePool(0x93054188d876f558f4a66B2EF1d97d16eDf0895B);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IThreeCrypto constant public threecrypto = IThreeCrypto(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    IConvex public constant cvxRen = IConvex(0xB65eDE134521F0EFD4E943c835F450137dC6E83e);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant CurveToken = IERC20(0x49849C98ae39Fff122806C06791Fa73784FB3675);\n    IERC20 public constant WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n        WBTC.approve(address(threecrypto), type(uint256).max);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(this), 0, shareFrom);\n\n        cvxRen.withdrawAndUnwrap(amountFrom);\n\n        renCrv.remove_liquidity_one_coin(amountFrom, 1, 0);\n\n        uint256 amountOne = WBTC.balanceOf(address(this));\n\n        threecrypto.exchange(1, 0, amountOne, 0);\n\n        uint256 amountIntermediate = TETHER.balanceOf(address(this));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/swappers/Liquidations/FTMSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\n\ncontract FTMSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    \n    IUniswapV2Pair constant pair = IUniswapV2Pair(0xB32b31DfAfbD53E310390F641C7119b5B9Ea0488);\n    IERC20 constant WFTM = IERC20(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n    IERC20 public constant MIM = IERC20(0x82f0B8B456c1A451378467398982d4834b6829c1);\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom,) = bentoBox.withdraw(fromToken, address(this), address(pair), 0, shareFrom);\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        uint256 amountTo = getAmountOut(amountFrom, reserve0, reserve1);\n        pair.swap(0, amountTo, address(bentoBox), new bytes(0));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Liquidations/ALCXSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapper.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract ALCXSwapper is ISwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);    \n    IERC20 public constant ALCX = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IUniswapV2Pair constant ALCX_WETH = IUniswapV2Pair(0xC3f279090a47e80990Fe3a9c30d24Cb117EF91a8);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n\n    constructor() public {\n        TETHER.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n// Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapper\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(fromToken, address(this), address(ALCX_WETH), 0, shareFrom);\n\n        (uint256 reserve0, uint256 reserve1, ) = ALCX_WETH.getReserves();\n        \n        uint256 amountFirst = getAmountOut(amountFrom, reserve1, reserve0);\n\n        ALCX_WETH.swap(amountFirst, 0, address(pair), new bytes(0));\n\n        (reserve0, reserve1, ) = pair.getReserves();\n        \n        uint256 amountIntermediate = getAmountOut(amountFirst, reserve0, reserve1);\n        pair.swap(0, amountIntermediate, address(this), new bytes(0));\n\n        uint256 amountTo = MIM3POOL.exchange_underlying(3, 0, amountIntermediate, 0, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(toToken, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapper\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/YVYFILevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract YVYFILevSwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    YearnVault public constant YFI_VAULT = YearnVault(0xE14d13d8B3b85aF791b2AADD661cDBd5E6097Db1);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IUniswapV2Pair constant YFI_WETH = IUniswapV2Pair(0x088ee5007C98a9677165D78dD2109AE4a3D04d0C);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n    IERC20 constant YFI = IERC20(0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        YFI.approve(address(YFI_VAULT), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        uint256 amountFirst;\n\n        {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        amountFirst = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(pair));\n\n        }\n\n        uint256 amountIntermediate;\n        \n        {\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        amountIntermediate  = getAmountOut(amountFirst, reserve1, reserve0);\n        pair.swap(amountIntermediate, 0, address(YFI_WETH), new bytes(0));\n\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = YFI_WETH.getReserves();\n        \n        uint256 amountInt2 = getAmountOut(amountIntermediate, reserve1, reserve0);\n        \n        YFI_WETH.swap(amountInt2, 0, address(this), new bytes(0));\n\n        uint256 amountTo = YFI_VAULT.deposit(type(uint256).max, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(IERC20(address(YFI_VAULT)), address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/YVXSushiLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface SushiBar is IERC20 {\n    function leave(uint256 share) external;\n    function enter(uint256 amount) external;\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract YVXSushiLevSwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);    \n    SushiBar public constant xSushi = SushiBar(0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272);\n    IERC20 public constant SUSHI = IERC20(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n    IUniswapV2Pair constant SUSHI_WETH = IUniswapV2Pair(0x795065dCc9f64b5614C407a6EFDC400DA6221FB0);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        SUSHI.approve(address(xSushi), type(uint256).max);\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        uint256 amountFirst;\n        uint256 amountIntermediate;\n\n        {\n\n        (uint256 amountMIMFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        amountFirst = MIM3POOL.exchange_underlying(0, 3, amountMIMFrom, 0, address(pair));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        amountIntermediate = getAmountOut(amountFirst, reserve1, reserve0);\n\n        }\n\n        uint256 amountThird;\n\n        {\n        \n        pair.swap(amountIntermediate, 0, address(SUSHI_WETH), new bytes(0));\n\n        (uint256 reserve0, uint256 reserve1, ) = SUSHI_WETH.getReserves();\n        \n        amountThird = getAmountOut(amountIntermediate, reserve1, reserve0);\n\n        }\n\n        SUSHI_WETH.swap(amountThird, 0, address(this), new bytes(0));\n\n        xSushi.enter(amountThird);\n\n        uint256 amountTo = xSushi.balanceOf(address(this));\n\n        xSushi.transfer(address(bentoBox), amountTo);\n\n        (, shareReturned) = bentoBox.deposit(xSushi, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n}\n"
    },
    "contracts/swappers/Leverage/YVWETHLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface YearnVault {\n    function withdraw() external returns (uint256);\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\ncontract YVWETHLevSwapper{\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public immutable bentoBox;\n\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7); \n    YearnVault public constant WETH_VAULT = YearnVault(0xa258C4606Ca8206D8aA700cE2143D7db854D168c);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n    IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor(\n        IBentoBoxV1 bentoBox_\n    ) public {\n        bentoBox = bentoBox_;\n        WETH.approve(address(WETH_VAULT), type(uint256).max);\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        uint256 amountIntermediate = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(pair));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        uint256  amountInt2 = getAmountOut(amountIntermediate, reserve1, reserve0);\n        pair.swap(amountInt2, 0, address(this), new bytes(0));\n\n        uint256 amountTo = WETH_VAULT.deposit(type(uint256).max, address(bentoBox));\n\n        (, shareReturned) = bentoBox.deposit(IERC20(address(WETH_VAULT)), address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/wOHMLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface IWOHM is IERC20 {\n    function wrap( uint _amount ) external returns ( uint );\n    function unwrap( uint _amount ) external returns ( uint );\n    function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\ninterface IStakingManager {\n    function unstake( uint _amount, bool _trigger ) external;\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n    function claim ( address _recipient ) external;\n}\n\ncontract wOHMLevSwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    IUniswapV2Pair constant OHM_DAI = IUniswapV2Pair(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant SOHM = IERC20(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F);\n    IWOHM public constant WOHM = IWOHM(0xCa76543Cf381ebBB277bE79574059e32108e3E65);\n    IStakingManager public constant STAKING_MANAGER = IStakingManager(0xFd31c7d00Ca47653c6Ce64Af53c1571f9C36566a);\n    IERC20 public constant OHM = IERC20(0x383518188C0C6d7730D91b2c03a03C837814a899);\n    constructor(\n    ) public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n        OHM.approve(address(STAKING_MANAGER), type(uint256).max);\n        SOHM.approve(address(WOHM), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        uint256 amountFirst;\n        uint256 amountIntermediate;\n\n        {\n\n        (uint256 amountMIMFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        amountFirst = MIM3POOL.exchange_underlying(0, 1, amountMIMFrom, 0, address(OHM_DAI));\n\n        (uint256 reserve0, uint256 reserve1, ) = OHM_DAI.getReserves();\n        amountIntermediate = getAmountOut(amountFirst, reserve1, reserve0);\n        }\n        \n        OHM_DAI.swap(amountIntermediate, 0, address(this), new bytes(0));\n\n        STAKING_MANAGER.stake(amountIntermediate, address(this));\n\n        STAKING_MANAGER.claim(address(this));\n\n        uint256 amountTo = WOHM.wrap(amountIntermediate);\n\n        WOHM.transfer(address(bentoBox), amountTo);\n\n        (, shareReturned) = bentoBox.deposit(WOHM, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n\n}"
    },
    "contracts/swappers/Leverage/SpellLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract SpellLevSwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);    \n    IERC20 public constant SPELL = IERC20(0x090185f2135308BaD17527004364eBcC2D37e5F6);\n    IUniswapV2Pair constant SPELL_ETH = IUniswapV2Pair(0xb5De0C3753b6E1B4dBA616Db82767F17513E6d4E);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        uint256 amountFirst = MIM3POOL.exchange_underlying(0, 3, amountFrom, 0, address(pair));\n        \n        uint256 amountIntermediate;\n        {\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        amountIntermediate = getAmountOut(amountFirst, reserve1, reserve0);\n        pair.swap(amountIntermediate, 0, address(SPELL_ETH), new bytes(0));\n\n        }\n\n        uint256 amountTo;\n\n        {\n\n        (uint256 reserve0, uint256 reserve1, ) = SPELL_ETH.getReserves();\n        \n        amountTo = getAmountOut(amountIntermediate, reserve1, reserve0);\n        \n        }\n\n        SPELL_ETH.swap(amountTo, 0, address(bentoBox), new bytes(0));\n\n        (, shareReturned) = bentoBox.deposit(SPELL, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/FTMLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ncontract FTMLevSwapper{\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0xB32b31DfAfbD53E310390F641C7119b5B9Ea0488);\n    IERC20 constant WFTM = IERC20(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n    IERC20 public constant MIM = IERC20(0x82f0B8B456c1A451378467398982d4834b6829c1);\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(MIM, address(this), address(pair), 0, shareFrom);\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        \n        uint256  amountTo = getAmountOut(amountFrom, reserve1, reserve0);\n        pair.swap(amountTo, 0, address(bentoBox), new bytes(0));\n\n        (, shareReturned) = bentoBox.deposit(WFTM, address(bentoBox), recipient, amountTo, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/swappers/Leverage/ALCXLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n}\n\ninterface TetherToken {\n    function approve(address _spender, uint256 _value) external;\n}\n\ncontract ALCXLevSwapper {\n    using BoringMath for uint256;\n\n    // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    TetherToken public constant TETHER = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);    \n    IERC20 public constant ALCX = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IUniswapV2Pair constant ALCX_WETH = IUniswapV2Pair(0xC3f279090a47e80990Fe3a9c30d24Cb117EF91a8);\n    IUniswapV2Pair constant pair = IUniswapV2Pair(0x06da0fd433C1A5d7a4faa01111c044910A184553);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n\n    constructor() public {\n        MIM.approve(address(MIM3POOL), type(uint256).max);\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // Given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n\n        uint256 amountFirst;\n        uint256 amountIntermediate;\n\n        {\n\n        (uint256 amountMIMFrom, ) = bentoBox.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        amountFirst = MIM3POOL.exchange_underlying(0, 3, amountMIMFrom, 0, address(pair));\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        amountIntermediate = getAmountOut(amountFirst, reserve1, reserve0);\n\n        }\n\n        pair.swap(amountIntermediate, 0, address(ALCX_WETH), new bytes(0));\n\n        (uint256 reserve0, uint256 reserve1, ) = ALCX_WETH.getReserves();\n        \n        uint256 amountThird = getAmountOut(amountIntermediate, reserve0, reserve1);\n\n        ALCX_WETH.swap(0, amountThird, address(bentoBox), new bytes(0));\n\n        (, shareReturned) = bentoBox.deposit(ALCX, address(bentoBox), recipient, amountThird, 0);\n        extraShare = shareReturned.sub(shareToMin);\n    }\n}\n"
    },
    "contracts/mocks/FreelyMintableERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"./ERC20Mock.sol\";\n\ncontract FreelyMintableERC20Mock is ERC20Mock {\n    using BoringMath for uint256;\n\n    constructor(uint256 initialSupply) public ERC20Mock(initialSupply) {}\n\n    function mint(address to, uint256 amount) public {\n        totalSupply = totalSupply.add(amount);\n        balanceOf[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function burn(uint256 amount) public {\n        require(amount <= balanceOf[msg.sender], \"MIM: not enough\");\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    uint256 public override totalSupply;\n\n    constructor(uint256 _initialAmount) public {\n        // Give the creator all initial tokens\n        balanceOf[msg.sender] = _initialAmount;\n        // Update total supply\n        totalSupply = _initialAmount;\n    }\n}\n"
    },
    "contracts/mocks/ExternalFunctionMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\n\ncontract ExternalFunctionMock {\n    using BoringMath for uint256;\n\n    event Result(uint256 output);\n\n    function sum(uint256 a, uint256 b) external returns (uint256 c) {\n        c = a.add(b);\n        emit Result(c);\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/BoringMultipleNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./libraries/BoringAddress.sol\";\nimport \"./libraries/BoringMath.sol\";\nimport \"./interfaces/IERC721TokenReceiver.sol\";\n\n// solhint-disable avoid-low-level-calls\n\nabstract contract BoringMultipleNFT {\n    /// This contract is an EIP-721 compliant contract with enumerable support\n    /// To optimize for gas, tokenId is sequential and start at 0. Also, tokens can't be removed/burned.\n    using BoringAddress for address;\n    using BoringMath for uint256;\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    uint256 public totalSupply = 0;\n\n    struct TokenInfo {\n        address owner;\n        uint24 index; // index in the tokensOf array, one address can hold a maximum of 16,777,216 tokens\n        uint72 data; // data field can be usse to store traits\n    }\n\n    // operator mappings as per usual\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    mapping(address => uint256[]) public tokensOf; // Array of tokens owned by\n    mapping(uint256 => TokenInfo) internal _tokens; // The index in the tokensOf array for the token, needed to remove tokens from tokensOf\n    mapping(uint256 => address) internal _approved; // keep track of approved nft\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return\n            interfaceID == this.supportsInterface.selector || // EIP-165\n            interfaceID == 0x80ac58cd; // EIP-721\n    }\n\n    function approve(address approved, uint256 tokenId) public payable {\n        address owner = _tokens[tokenId].owner;\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"Not allowed\");\n        _approved[tokenId] = approved;\n        emit Approval(owner, approved, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address approved) {\n        require(tokenId < totalSupply, \"Invalid tokenId\");\n        return _approved[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokens[tokenId].owner;\n        require(owner != address(0), \"No owner\");\n        return owner;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"No 0 owner\");\n        return tokensOf[owner].length;\n    }\n\n    function _transferBase(\n        uint256 tokenId,\n        address from,\n        address to,\n        uint72 data\n    ) internal {\n        address owner = _tokens[tokenId].owner;\n        require(from == owner, \"From not owner\");\n\n        uint24 index;\n        // Remove the token from the current owner's tokensOf array\n        if (from != address(0)) {\n            index = _tokens[tokenId].index; // The index of the item to remove in the array\n            data = _tokens[tokenId].data;\n            uint256 last = tokensOf[from].length - 1;\n            uint256 lastTokenId = tokensOf[from][last];\n            tokensOf[from][index] = lastTokenId; // Copy the last item into the slot of the one to be removed\n            _tokens[lastTokenId].index = index; // Update the token index for the last item that was moved\n            tokensOf[from].pop(); // Delete the last item\n        }\n\n        index = uint24(tokensOf[to].length);\n        tokensOf[to].push(tokenId);\n        _tokens[tokenId] = TokenInfo({owner: to, index: index, data: data});\n\n        // EIP-721 seems to suggest not to emit the Approval event here as it is indicated by the Transfer event.\n        _approved[tokenId] = address(0);\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(msg.sender == from || msg.sender == _approved[tokenId] || isApprovedForAll[from][msg.sender], \"Transfer not allowed\");\n        require(to != address(0), \"No zero address\");\n        // check for owner == from is in base\n        _transferBase(tokenId, from, to, 0);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public payable {\n        _transfer(from, to, tokenId);\n        if (to.isContract()) {\n            require(\n                IERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) ==\n                    bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\n                \"Wrong return value\"\n            );\n        }\n    }\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        require(tokenId < totalSupply, \"Not minted\");\n        return _tokenURI(tokenId);\n    }\n\n    function _tokenURI(uint256 tokenId) internal view virtual returns (string memory);\n\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply, \"Out of bounds\");\n        return index; // This works due the optimization of sequential tokenIds and no burning\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\n        return tokensOf[owner][index];\n    }\n\n    function _mint(address owner, uint72 data) internal {\n        _transferBase(totalSupply, address(0), owner, data);\n        totalSupply++;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n// solhint-disable no-inline-assembly\n\nlibrary BoringAddress {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"
    },
    "@boringcrypto/boring-solidity/contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/mocks/ERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"@boringcrypto/boring-solidity/contracts/BoringMultipleNFT.sol\";\n\ncontract ERC721Mock is BoringMultipleNFT {\n    function mint(address owner) public returns (uint256 id) {\n        id = totalSupply;\n        _mint(owner, 0);\n    }\n\n    function _tokenURI(uint256) internal view override returns (string memory) {\n        return \"\";\n    }\n}\n"
    },
    "contracts/MinimalTimeLock.sol": {
      "content": "//SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\n\n// Modified from https://etherscan.io/address/0x6d903f6003cca6255d85cca4d3b5e5146dc33925#code and https://github.com/boringcrypto/dictator-dao/blob/main/contracts/DictatorDAO.sol#L225\ncontract MinimalTimeLock is BoringOwnable {    \n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, bytes data, uint256 eta);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, bytes data);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, bytes data);\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant DELAY = 2 days;\n    mapping(bytes32 => uint256) public queuedTransactions;\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public onlyOwner returns (bytes32) {\n\n        bytes32 txHash = keccak256(abi.encode(target, value, data));\n        uint256 eta = block.timestamp + DELAY;\n        queuedTransactions[txHash] = eta;\n\n        emit QueueTransaction(txHash, target, value, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public onlyOwner {\n\n        bytes32 txHash = keccak256(abi.encode(target, value, data));\n        queuedTransactions[txHash] = 0;\n\n        emit CancelTransaction(txHash, target, value, data);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public onlyOwner payable returns (bytes memory) {\n\n        bytes32 txHash = keccak256(abi.encode(target, value, data));\n        uint256 eta = queuedTransactions[txHash];\n        require(block.timestamp >= eta, \"Too early\");\n        require(block.timestamp <= eta + GRACE_PERIOD, \"Tx stale\");\n\n        queuedTransactions[txHash] = 0;\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(data);\n        require(success, \"Tx reverted :(\");\n\n        emit ExecuteTransaction(txHash, target, value, data);\n\n        return returnData;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}